<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI æ‰‹åŠ¿åˆ‡æ°´æœ (MediaPipe)</title>
    <link href="https://fonts.googleapis.com/css2?family=Shojumaru&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <style>
        html, body {
            width: 100%;
            height: 100%;
        }

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: radial-gradient(circle, #5d4037 0%, #3e2723 100%);
            /* æ·±è‰²æœ¨çº¹èƒŒæ™¯åŸºè°ƒ */
            font-family: 'Shojumaru', cursive, 'Segoe UI', sans-serif;
            user-select: none;
            touch-action: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100dvh; /* é¿å…ç§»åŠ¨ç«¯åœ°å€æ æŒ¤å  */
            /* background-image: url('...'); ç§»é™¤é”™è¯¯çš„ base64 */
        }

        /* è§†é¢‘å…ƒç´ éšè—ï¼Œæˆ‘ä»¬ç”»åœ¨Canvasä¸Š */
        #input-video {
            position: absolute;
            top: 0;
            left: 0;
            width: 1px;
            height: 1px;
            opacity: 0;
            pointer-events: none;
            z-index: -1;
        }

        #game-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* UI å±‚ */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            height: 100dvh; /* é€‚é…ç§»åŠ¨ç«¯åŠ¨æ€è§†å£é«˜åº¦ */
            z-index: 2;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: flex-end; /* ç¡®ä¿ hud-bottom ä½äºåº•éƒ¨ */
        }

        .hud-top {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            padding: 0;
        }

        .score-container {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 180px;
            height: 80px;
            /* æ¨¡æ‹Ÿæœ¨ç‰Œæ•ˆæœ */
            background: linear-gradient(to bottom, #8d6e63, #5d4037);
            border: 4px solid #4e342e;
            border-radius: 10px;
            box-shadow: 5px 5px 15px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            justify-content: center;
            padding-left: 70px;
            /* ç•™å‡ºå›¾æ ‡ä½ç½® */
            transform: rotate(-2deg);
        }

        .score-icon {
            position: absolute;
            left: -15px;
            top: 10px;
            font-size: 50px;
            filter: drop-shadow(2px 2px 2px rgba(0, 0, 0, 0.5));
        }

        .score-label {
            font-size: 14px;
            color: #d7ccc8;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .score-value {
            font-size: 36px;
            color: #ffeb3b;
            text-shadow: 2px 2px 0 #3e2723;
            line-height: 1;
        }

        .high-score-value {
            font-size: 12px;
            color: #a1887f;
            margin-top: 2px;
            font-weight: bold;
        }

        .lives-container {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 5px;
        }

        .life-icon {
            font-size: 40px;
            color: #ff0000;
            filter: drop-shadow(2px 2px 2px rgba(0, 0, 0, 0.5));
            transition: transform 0.2s;
        }

        .life-lost {
            color: #555;
            transform: scale(0.8);
            opacity: 0.5;
        }

        .gesture-status-container {
            position: absolute;
            bottom: 100px;
            right: 20px;
            text-align: right;
            max-width: 300px;
            /* é™åˆ¶æœ€å¤§å®½åº¦é˜²æ­¢æº¢å‡º */
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .gesture-status {
            font-size: 24px;
            color: #aaffaa;
            text-shadow: 2px 2px 0 #000;
        }

        .time-display {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 32px;
            color: #fff;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            font-family: monospace;
            z-index: 5;
        }

        .hud-bottom {
            padding: 20px;
            padding-bottom: max(20px, env(safe-area-inset-bottom)); /* é€‚é…å…¨é¢å±åº•éƒ¨å®‰å…¨åŒº */
            background: linear-gradient(to top, rgba(62, 39, 35, 0.9), transparent);
            color: #ffd700;
            text-align: center;
            text-shadow: 1px 1px 0 #000;
        }

        .gesture-guide {
            display: flex;
            justify-content: center;
            gap: 40px;
            margin-bottom: 10px;
        }

        .guide-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-size: 14px;
            opacity: 0.9;
        }

        .guide-icon {
            font-size: 32px;
            margin-bottom: 5px;
            filter: drop-shadow(2px 2px 2px rgba(0, 0, 0, 0.5));
        }

        /* èœå•è¦†ç›–å±‚ */
        #menu-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            pointer-events: auto;
        }

        .menu-content {
            text-align: center;
            /* ä»¿æœ¨æ¿æ•ˆæœ */
            background: #8d6e63;
            background: linear-gradient(135deg, #8d6e63 0%, #5d4037 100%);
            padding: 50px;
            border-radius: 10px;
            border: 8px solid #4e342e;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.8), inset 0 0 20px rgba(0, 0, 0, 0.3);
            max-width: 500px;
            width: 80%;
        }

        h1 {
            margin: 0 0 30px 0;
            font-size: 64px;
            color: #ffeb3b;
            text-shadow: 4px 4px 0 #bf360c, 6px 6px 10px rgba(0, 0, 0, 0.5);
            transform: rotate(-5deg);
        }

        button {
            background: linear-gradient(to bottom, #8bc34a 0%, #558b2f 100%);
            border: 2px solid #33691e;
            padding: 15px 50px;
            color: white;
            font-family: 'Shojumaru', cursive;
            font-size: 28px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
            margin: 15px;
            text-shadow: 1px 1px 0 #33691e;
            box-shadow: 0 5px 0 #33691e, 0 10px 10px rgba(0, 0, 0, 0.3);
        }

        button:hover {
            transform: translateY(2px);
            box-shadow: 0 3px 0 #33691e, 0 5px 10px rgba(0, 0, 0, 0.3);
            filter: brightness(1.1);
        }

        button:active {
            transform: translateY(5px);
            box-shadow: none;
        }

        .hidden {
            display: none !important;
        }

        /* åŠ è½½åŠ¨ç”» */
        .loader {
            border: 6px solid #d7ccc8;
            border-top: 6px solid #ff5722;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* æµ®åŠ¨å¾—åˆ†åŠ¨ç”» */
        .floating-score {
            /* å·²åºŸå¼ƒï¼Œæ”¹ç”¨ Canvas ç»˜åˆ¶ */
            display: none;
        }

        /* å“åº”å¼é€‚é… (Responsive Design) */

        /* å¹³æ¿/å°å±å¹•ç¬”è®°æœ¬ (å®½åº¦å°äº 1024px) */
        @media (max-width: 1024px) {
            .score-container {
                transform: scale(0.85);
                top: 15px;
                left: 15px;
                transform-origin: top left;
            }

            .lives-container {
                transform: scale(0.85);
                top: 15px;
                right: 15px;
                transform-origin: top right;
            }
        }

        /* æ‰‹æœºç«–å± (å®½åº¦å°äº 600px) */
        @media (max-width: 600px) {
            .score-container {
                transform: scale(0.6);
                top: 10px;
                left: 10px;
                transform-origin: top left;
                max-width: 45%;
                /* é˜²æ­¢ä¸å³ä¾§é‡å  */
            }

            .lives-container {
                transform: scale(0.6);
                top: 10px;
                right: 10px;
                transform-origin: top right;
                max-width: 45%;
            }

            /* çŠ¶æ€æç¤ºç§»åˆ°åº•éƒ¨ä¸­å¤® */
            .gesture-status-container {
                bottom: 160px; /* æé«˜ä½ç½®ï¼Œé¿å…è¢«åº•éƒ¨æ“ä½œæŒ‡å—é®æŒ¡ (é€‚é…å…¨é¢å±) */
                /* ä½äºæ“ä½œæŒ‡å—ä¸Šæ–¹ */
                right: auto;
                left: 50%;
                width: 100%;
                transform: translateX(-50%) scale(0.7);
                transform-origin: bottom center;
                text-align: center;
                white-space: nowrap;
                /* é˜²æ­¢æ¢è¡Œ */
            }

            .hud-bottom {
                padding: 10px;
                padding-bottom: 20px;
                /* å¢åŠ åº•éƒ¨ç•™ç™½ */
            }

            .guide-item {
                font-size: 10px;
            }

            .guide-icon {
                font-size: 20px;
                margin-bottom: 2px;
            }

            .gesture-guide {
                gap: 15px;
            }

            /* èœå•é€‚é… */
            .menu-content {
                padding: 20px;
                width: 90%;
                max-width: 350px;
            }

            h1 {
                font-size: 32px;
                margin-bottom: 15px;
            }

            button {
                padding: 10px 30px;
                font-size: 18px;
                margin: 10px;
            }
        }

        /* æ‰‹æœºæ¨ªå± (é«˜åº¦å°äº 500px) - æ¸¸æˆé€šå¸¸æ¨ªå±ç© */
        @media (max-height: 500px) {
            .score-container {
                transform: scale(0.55);
                top: 5px;
                left: 5px;
                transform-origin: top left;
            }

            .lives-container {
                transform: scale(0.55);
                top: 5px;
                right: 5px;
                transform-origin: top right;
            }

            .gesture-status-container {
                bottom: 40px; /* é¿å¼€åº•éƒ¨æç®€æŒ‡å— */
                right: 10px;
                transform: scale(0.5);
                transform-origin: bottom right;
            }

            .hud-bottom {
                padding: 5px;
            }

            .guide-icon {
                font-size: 16px;
            }

            .guide-item span:last-child {
                display: none;
                /* æ¨ªå±ç©ºé—´ä¸è¶³æ—¶éšè—æ–‡å­—è¯´æ˜ */
            }

            .menu-content {
                padding: 15px;
                width: 60%;
                max-width: 400px;
                display: flex;
                flex-direction: column;
                justify-content: center;
            }

            h1 {
                font-size: 28px;
                margin-bottom: 10px;
            }

            button {
                padding: 8px 20px;
                font-size: 16px;
                margin: 5px;
            }

            .loader {
                width: 40px;
                height: 40px;
                margin: 10px auto;
            }
        }
    </style>
</head>

<body>

    <div id="game-container">
        <video id="input-video" autoplay playsinline></video>
        <canvas id="game-canvas"></canvas>

        <div id="ui-layer">
            <div class="hud-top">
                <!-- å·¦ä¸Šè§’åˆ†æ•°æ¿ -->
                <div class="score-container">
                    <div class="score-icon">ğŸ‰</div>
                    <div class="score-label">Score</div>
                    <div class="score-value" id="score">0</div>
                    <div class="high-score-value">Best: <span id="high-score">0</span></div>
                </div>

                <!-- å³ä¸Šè§’ç”Ÿå‘½å€¼ -->
                <div class="lives-container" id="lives-container">
                    <div class="life-icon">â¤ï¸</div>
                    <div class="life-icon">â¤ï¸</div>
                    <div class="life-icon">â¤ï¸</div>
                </div>

                <!-- å³ä¸‹è§’çŠ¶æ€ -->
                <div class="gesture-status-container">
                    <div class="gesture-status" id="gesture-status">ç­‰å¾…æ‘„åƒå¤´...</div>
                </div>
                
                <!-- é¡¶éƒ¨æ—¶é—´æ˜¾ç¤º -->
                <div class="time-display" id="game-time">00:00</div>
            </div>

            <div class="hud-bottom">
                <div class="gesture-guide">
                    <div class="guide-item">
                        <span class="guide-icon">â˜ï¸</span>
                        <span>é£ŸæŒ‡åˆ‡æ°´æœ</span>
                    </div>
                    <div class="guide-item">
                        <span class="guide-icon">âœŠ</span>
                        <span>æ¡æ‹³é¿ç‚¸å¼¹</span>
                    </div>
                    <div class="guide-item">
                        <span class="guide-icon">ğŸ–ï¸</span>
                        <span>å¼ æ‰‹æš‚åœ</span>
                    </div>
                    <div class="guide-item">
                        <span class="guide-icon">ğŸ‘</span>
                        <span>åŒæ‰‹é‡å¼€</span>
                    </div>
                </div>
                <div>ä¿æŒè·ç¦»æ‘„åƒå¤´ 0.5 - 1 ç±³ä»¥è·å¾—æœ€ä½³æ•ˆæœ</div>
            </div>
        </div>

        <div id="menu-overlay">
            <div class="menu-content">
                <h1>AI åˆ‡æ°´æœ</h1>
                <div id="loading-message">
                    <div class="loader"></div>
                    <p>æ­£åœ¨åˆå§‹åŒ–æ‘„åƒå¤´å’Œæ¨¡å‹...</p>
                </div>
                <div id="start-menu" class="hidden">
                    <p>ä½¿ç”¨é£ŸæŒ‡ä½œä¸ºåˆ€åˆƒï¼Œåˆ‡ç¢æ°´æœï¼</p>
                    <p>å°å¿ƒç‚¸å¼¹ ğŸ’£</p>
                    <button onclick="game.startGame()">å¼€å§‹æ¸¸æˆ</button>
                </div>
                <div id="game-over-menu" class="hidden">
                    <h2>æ¸¸æˆç»“æŸ</h2>
                    <p>æœ€ç»ˆå¾—åˆ†: <span id="final-score">0</span></p>
                    <button onclick="game.restartGame()">å†ç©ä¸€æ¬¡</button>
                </div>
                <div id="pause-menu" class="hidden">
                    <h2>å·²æš‚åœ</h2>
                    <button onclick="game.resumeGame()">ç»§ç»­</button>
                </div>
                <div id="countdown-display" class="hidden"
                    style="font-size: 120px; font-weight: bold; color: #fff; text-shadow: 0 0 30px #ff0000;">3</div>
            </div>
        </div>
    </div>

    <script>
        /**
         * æ¸¸æˆé…ç½®ä¸å¸¸é‡
         */
            const CONFIG = {
                GRAVITY: 0.5,
                SPAWN_RATE_INITIAL: 28, // åˆå§‹æ›´æ…¢ï¼Œé™ä½å¼€å±€å‹åŠ›
            MAX_FRUITS: 25, // å¢åŠ åŒå±ä¸Šé™
            BLADE_LIFETIME: 10, // åˆ€å…‰è½¨è¿¹ä¿ç•™å¸§æ•°
            GESTURE_HOLD_TIME: 3000, // æ¯«ç§’
            BOMB_PENALTY: 10,
            COMBO_TIME_WINDOW: 300, // æ¯«ç§’
        };

        const FRUIT_TYPES = [
            { type: 'watermelon', icon: 'ğŸ‰', score: 5, color: '#ff5555', size: 100 },
            { type: 'orange', icon: 'ğŸŠ', score: 3, color: '#ffaa00', size: 80 },
            { type: 'apple', icon: 'ğŸ', score: 3, color: '#ff4444', size: 80 },
            { type: 'banana', icon: 'ğŸŒ', score: 2, color: '#ffee00', size: 90 },
            { type: 'coconut', icon: 'ğŸ¥¥', score: 4, color: '#eeeeee', size: 85 },
        ];

        const SPECIAL_ITEMS = [
            { type: 'bomb', icon: 'ğŸ’£', score: -10, color: '#000000', size: 100, weight: 0.1 },
            { type: 'ice', icon: 'ğŸ§Š', score: 0, color: '#aaddff', size: 80, weight: 0.05 } // å†°å†»è‰è“/å†°å—
        ];

        /**
         * æ¸¸æˆä¸»ç±»
         */
        class FruitNinjaGame {
            constructor() {
                this.canvas = document.getElementById('game-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.video = document.getElementById('input-video');

                const vv = window.visualViewport;
                this.width = vv ? vv.width : window.innerWidth;
                this.height = vv ? vv.height : window.innerHeight;
                this.canvas.width = this.width;
                this.canvas.height = this.height;

                this.state = 'LOADING';
                this.score = 0;
                this.highScore = localStorage.getItem('fruit_ninja_highscore') || 0;
                this.lives = 3;
                this.gameTime = 0;
                this.lastFrameTime = 0;

                this.fruits = [];
                this.particles = [];
                this.splatters = []; // èƒŒæ™¯æœæ±æº…å°„
                this.bladeTrails = [[], []]; // æ”¯æŒåŒæ‰‹è½¨è¿¹
                this.floatingTexts = [];

                this.handLandmarks = null;
                this.handStates = ['NONE', 'NONE']; // åŒæ‰‹çŠ¶æ€
                this.gestureState = 'NONE'; // å…¨å±€çŠ¶æ€ (ç”¨äºæš‚åœ/é‡å¼€)
                this.gestureTimer = 0;
                this.lastActionTime = 0; // ä¸Šæ¬¡è§¦å‘åŠ¨ä½œçš„æ—¶é—´ (å†·å´ç”¨)
                this.lastCooldownSec = 0; // å†·å´å€’è®¡æ—¶éŸ³æ•ˆè®°å½•
                this.pauseStartTime = null; // è®°å½•æš‚åœå¼€å§‹æ—¶é—´ï¼Œç”¨äºä¿®æ­£è®¡æ—¶
                this.lastDisplayedTime = -1; // ä¸Šæ¬¡æ¸²æŸ“çš„ç§’æ•°ï¼Œç”¨äºé˜²æŠ–æ˜¾ç¤º

                this.spawnTimer = 0;
                this.difficultyMultiplier = 0.3;
                this.timeSlowFactor = 1;
                this.timeSlowTimer = 0;

                this.comboCount = 0;
                this.lastSliceTime = 0;

                // éš¾åº¦æ¸è¿›è®¾ç½®ï¼ˆéšæ—¶é—´è‡ªåŠ¨ä»ç®€å•->å›°éš¾ï¼Œä¸å†éœ€è¦æ‰‹åŠ¨é€‰æ‹©ï¼‰
                this.difficultyRamp = {
                    duration: 120, // 120ç§’å†…çº¿æ€§æ‹‰æ»¡éš¾åº¦
                    spawnEasy: 42,
                    spawnHard: 22,
                    floorEasy: 30,
                    floorHard: 18,
                    maxEasy: 12,
                    maxHard: 20,
                    apexMinEasy: 0.55,
                    apexMinHard: 0.78,
                    apexMaxEasy: 0.68,
                    apexMaxHard: 0.9,
                    specialScaleEasy: 0.7,
                    specialScaleHard: 1.3,
                    burstScaleEasy: 0.7,
                    burstScaleHard: 1.3,
                    difficultyBaseEasy: 0.2,
                    difficultyBaseHard: 0.35
                };

                // CDN é…ç½®
                this.cdnList = [
                    { name: 'Local (æœ¬åœ° ./hands/)', url: 'hands/' },
                    { name: 'JSDelivr (æ¨è)', url: 'https://cdn.jsdelivr.net/npm/@mediapipe/hands/' },
                    { name: 'Unpkg (å¤‡ç”¨)', url: 'https://unpkg.com/@mediapipe/hands/' },
                    { name: 'JSDelivr Fastly', url: 'https://fastly.jsdelivr.net/npm/@mediapipe/hands/' }
                ];
                this.currentCdnIndex = 0; // é»˜è®¤å…ˆç”¨æœ¬åœ°ï¼Œåç»­å¯åˆ‡æ¢ CDN

                // ç»‘å®šUIå…ƒç´ 
                this.ui = {
                    menuOverlay: document.getElementById('menu-overlay'),
                    score: document.getElementById('score'),
                    highScore: document.getElementById('high-score'),
                    livesContainer: document.getElementById('lives-container'),
                    status: document.getElementById('gesture-status'),
                    time: document.getElementById('game-time'),
                    loadingMsg: document.getElementById('loading-message'),
                    startMenu: document.getElementById('start-menu'),
                    gameOverMenu: document.getElementById('game-over-menu'),
                    pauseMenu: document.getElementById('pause-menu'),
                    finalScore: document.getElementById('final-score'),
                    countdownDisplay: document.getElementById('countdown-display'),
                    // æŒ‰é’®å¼•ç”¨
                    startBtn: document.querySelector('#start-menu button'),
                    restartBtn: document.querySelector('#game-over-menu button'),
                    resumeBtn: document.querySelector('#pause-menu button')
                };

                this.ui.highScore.innerText = this.highScore;

                this.videoSource = { x: 0, y: 0, w: 0, h: 0 };

                // èœå•äº¤äº’çŠ¶æ€
                this.menuHoverTimer = 0;
                this.menuHoverTarget = null;
                this.menuHoverMaxTime = 30; // çº¦0.5ç§’æ‚¬åœè§¦å‘

                // æ€§èƒ½ä¼˜åŒ–ï¼šæ£€æµ‹ç§»åŠ¨è®¾å¤‡
                this.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                this.lastDetectionTime = 0;
                this.detectionInterval = 0; // å…¨å¹³å°å°½é‡å®æ—¶æ£€æµ‹ï¼Œå‡å°‘æ‰‹åŠ¿å»¶è¿Ÿ

                // ç§»åŠ¨ç«¯é™è½½å‚æ•°
                this.particleCount = this.isMobile ? 5 : 8;

                // åˆå§‹åº”ç”¨ç®€å•éš¾åº¦ï¼ˆåç»­è‡ªåŠ¨æ¸è¿›ï¼‰
                this.applyDifficultyRamp(0);

                this.initAudio();
                this.initMediaPipe();

                window.addEventListener('resize', () => this.resize());
            }

            initAudio() {
                try {
                    this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    
                    // ç”Ÿæˆå¤šç§è´¨æ„Ÿçš„å™ªå£°ç¼“å­˜
                    this.buffers = {
                        white: this.createNoiseBuffer('white'),
                        pink: this.createNoiseBuffer('pink'),
                        brown: this.createNoiseBuffer('brown'),
                        crunch: this.createNoiseBuffer('crunch'), // æ–°å¢ï¼šè„†è£‚çº¹ç†
                        wet: this.createNoiseBuffer('wet')        // æ–°å¢ï¼šç²˜ç¨ çº¹ç†
                    };

                    // é¢„è®¡ç®—å¤±çœŸæ›²çº¿ (ç”¨äºå¢åŠ å£°éŸ³çš„"è„"æ„Ÿå’Œå†²å‡»åŠ›)
                    this.distortionCurve = this.makeDistortionCurve(400);

                    // --- æ–°å¢ï¼šç”Ÿæˆæ··å“è„‰å†² (Impulse Response) ---
                    // è¿™ä¼šæ¨¡æ‹Ÿä¸€ä¸ªä¸­ç­‰å¤§å°çš„æˆ¿é—´/é“åœº
                    this.reverbBuffer = this.createReverbBuffer(1.5); // 1.5ç§’æ··å“å°¾éŸ³
                    
                    // åˆ›å»ºä¸»æ··å“èŠ‚ç‚¹ (Send Effect)
                    this.convolver = this.audioCtx.createConvolver();
                    this.convolver.buffer = this.reverbBuffer;
                    this.convolverGain = this.audioCtx.createGain();
                    this.convolverGain.gain.value = 0.3; // æ··å“æ¹¿å£°æ¯”ä¾‹ (30%)
                    
                    this.convolver.connect(this.convolverGain);
                    this.convolverGain.connect(this.audioCtx.destination);

                } catch (e) {
                    console.warn("AudioContext not supported");
                }
            }

            // è¾…åŠ©ï¼šç”Ÿæˆå¤±çœŸæ›²çº¿
            makeDistortionCurve(amount) {
                const k = typeof amount === 'number' ? amount : 50;
                const n_samples = 44100;
                const curve = new Float32Array(n_samples);
                const deg = Math.PI / 180;
                for (let i = 0; i < n_samples; ++i) {
                    const x = i * 2 / n_samples - 1;
                    curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
                }
                return curve;
            }

            // æ–°å¢ï¼šç”Ÿæˆæ··å“è„‰å†²çš„è¾…åŠ©å‡½æ•°
            createReverbBuffer(duration) {
                const sampleRate = this.audioCtx.sampleRate;
                const length = sampleRate * duration;
                const impulse = this.audioCtx.createBuffer(2, length, sampleRate);
                const left = impulse.getChannelData(0);
                const right = impulse.getChannelData(1);

                for (let i = 0; i < length; i++) {
                    const decay = Math.pow(1 - i / length, 2); // çº¿æ€§è¡°å‡
                    // å·¦å³å£°é“ç‹¬ç«‹çš„éšæœºå™ªå£°ï¼Œäº§ç”Ÿå®½å¹¿çš„ç«‹ä½“å£°åœº
                    left[i] = (Math.random() * 2 - 1) * decay;
                    right[i] = (Math.random() * 2 - 1) * decay;
                }
                return impulse;
            }

            // æ–°å¢ï¼šå»¶è¿Ÿæ’­æ”¾å‡½æ•°ï¼ˆæ ¸å¿ƒç”¨äºéŸ³æ•ˆæ—¶åºåˆ†å±‚ï¼‰
            playDelayed(fn, delayMs, ...args) {
                if (!this.audioCtx) return;
                setTimeout(() => fn.apply(this, args), delayMs);
            }

            createNoiseBuffer(type) {
                const bufferSize = this.audioCtx.sampleRate * 2.0; // 2ç§’ç¼“å­˜
                const buffer = this.audioCtx.createBuffer(1, bufferSize, this.audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                
                if (type === 'white') {
                    for (let i = 0; i < bufferSize; i++) {
                        data[i] = Math.random() * 2 - 1;
                    }
                } else if (type === 'pink') {
                    // ç²‰çº¢å™ªå£° (1/f) - å¬èµ·æ¥æ›´å‡è¡¡ã€è‡ªç„¶
                    let b0 = 0, b1 = 0, b2 = 0, b3 = 0, b4 = 0, b5 = 0, b6 = 0;
                    for (let i = 0; i < bufferSize; i++) {
                        const white = Math.random() * 2 - 1;
                        b0 = 0.99886 * b0 + white * 0.0555179;
                        b1 = 0.99332 * b1 + white * 0.0750759;
                        b2 = 0.96900 * b2 + white * 0.1538520;
                        b3 = 0.86650 * b3 + white * 0.3104856;
                        b4 = 0.55000 * b4 + white * 0.5329522;
                        b5 = -0.7616 * b5 - white * 0.0168980;
                        data[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;
                        data[i] *= 0.11; 
                        b6 = white * 0.115926;
                    }
                } else if (type === 'brown') {
                    // å¸ƒæœ—å™ªå£° (1/f^2) - å¬èµ·æ¥æ·±æ²‰ã€æµ‘åš
                    let lastOut = 0;
                    for (let i = 0; i < bufferSize; i++) {
                        const white = Math.random() * 2 - 1;
                        data[i] = (lastOut + (0.02 * white)) / 1.02;
                        lastOut = data[i];
                        data[i] *= 3.5; 
                    }
                } else if (type === 'crunch') {
                    // è„†è£‚çº¹ç†ï¼šç¨€ç–çš„é«˜æŒ¯å¹…è„‰å†²ï¼Œæ¨¡æ‹Ÿç‰©ä½“æ–­è£‚çš„å¾®è§‚ç»“æ„
                    // å¬èµ·æ¥åƒï¼šå™¼é‡Œå•ªå•¦
                    for (let i = 0; i < bufferSize; i++) {
                        // å¯†åº¦ 15% çš„éšæœºè„‰å†²
                        if (Math.random() > 0.85) {
                            data[i] = (Math.random() * 2 - 1);
                        } else {
                            data[i] = 0;
                        }
                    }
                } else if (type === 'wet') {
                    // ç²˜ç¨ çº¹ç†ï¼šè¢«ä½é¢‘æ··æ²Œä¿¡å·è°ƒåˆ¶çš„å™ªå£°
                    // å¬èµ·æ¥åƒï¼šå’•æ»‹å’•æ»‹
                    for (let i = 0; i < bufferSize; i++) {
                        const white = Math.random() * 2 - 1;
                        // å¤æ‚çš„å¹…åº¦è°ƒåˆ¶ (AM)
                        const mod = Math.sin(i * 0.01) * Math.cos(i * 0.003) * 0.5 + 0.5;
                        data[i] = white * mod;
                    }
                }
                return buffer;
            }

            playCountdownSound(num) {
                if (!this.audioCtx) return;
                const t = this.audioCtx.currentTime;
                const osc = this.audioCtx.createOscillator();
                const gain = this.audioCtx.createGain();

                osc.connect(gain);
                gain.connect(this.audioCtx.destination);

                // 3â†’2â†’1â†’GO éŸ³è°ƒé€’å¢ï¼Œä¸”æ·»åŠ è½»å¾®é¢‘ç‡æŠ–åŠ¨
                const baseFreq = 400 + (3 - num) * 200;
                const jitterFreq = baseFreq * (0.95 + Math.random() * 0.1); // Â±5%æŠ–åŠ¨
                osc.type = 'sine';
                osc.frequency.setValueAtTime(jitterFreq, t);

                // éŸ³é‡éšæ•°å­—å‡å°é€’å¢ï¼ˆ3â†’1éŸ³é‡å˜å¤§ï¼‰
                const volume = 0.1 + (3 - num) * 0.05;
                gain.gain.setValueAtTime(0, t);
                gain.gain.linearRampToValueAtTime(volume, t + 0.05);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.3);

                osc.start(t);
                osc.stop(t + 0.3);
            }

            playMissSound() {
                if (!this.audioCtx) return;
                const t = this.audioCtx.currentTime;
                
                // åˆ†å±‚ï¼šçŸ­ä¿ƒä¸‹é™éŸ³ + è½»å¾®ä½é¢‘é—·å“
                const osc = this.audioCtx.createOscillator();
                const gain = this.audioCtx.createGain();
                
                osc.connect(gain);
                gain.connect(this.audioCtx.destination);
                
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(200, t);
                osc.frequency.exponentialRampToValueAtTime(100, t + 0.3);
                
                gain.gain.setValueAtTime(0.1, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.3);
                
                osc.start(t);
                osc.stop(t + 0.3);

                // å åŠ ä½é¢‘é—·å“ï¼Œå¼ºåŒ–æŒ«è´¥æ„Ÿ
                const src = this.audioCtx.createBufferSource();
                src.buffer = this.buffers.brown;
                const filter = this.audioCtx.createBiquadFilter();
                const nGain = this.audioCtx.createGain();

                filter.type = 'lowpass';
                filter.frequency.value = 150;
                nGain.gain.setValueAtTime(0, t + 0.1);
                nGain.gain.linearRampToValueAtTime(0.08, t + 0.15);
                nGain.gain.exponentialRampToValueAtTime(0.01, t + 0.3);

                src.connect(filter);
                filter.connect(nGain);
                nGain.connect(this.audioCtx.destination);
                src.start(t + 0.1);
                src.stop(t + 0.35);
            }

            playSliceSound(fruit, cutSpeed = 0) {
                if (!this.audioCtx) return;

                const t = this.audioCtx.currentTime;
                const rand = (min, max) => Math.random() * (max - min) + min;
                
                // åŸºç¡€å‚æ•°è®¡ç®—
                const panX = Math.max(-0.8, Math.min(0.8, (fruit.x / this.width) * 2 - 1));
                const speedScale = Math.min(cutSpeed * 0.1, 1.0); 
                const volMod = 1.0 + speedScale * 0.4; 
                const tightMod = 1.0 - speedScale * 0.2; 
                
                // è¾…åŠ©å‡½æ•°ï¼šåˆ›å»ºéŸ³é¢‘é“¾è·¯
                const createChain = (distortionAmount = 0) => {
                    const panner = this.audioCtx.createStereoPanner();
                    panner.pan.value = panX;

                    if (distortionAmount > 0 && this.distortionCurve) {
                        const shaper = this.audioCtx.createWaveShaper();
                        shaper.curve = this.distortionCurve;
                        shaper.oversample = '4x';
                        const postGain = this.audioCtx.createGain();
                        postGain.gain.value = 0.8; 
                        shaper.connect(postGain);
                        postGain.connect(panner);
                        panner.connect(this.audioCtx.destination);
                        if (this.convolver) {
                            const send = this.audioCtx.createGain();
                            send.gain.value = 0.3; 
                            panner.connect(send);
                            send.connect(this.convolver);
                        }
                        return shaper; 
                    } else {
                        panner.connect(this.audioCtx.destination);
                        if (this.convolver) {
                            const send = this.audioCtx.createGain();
                            send.gain.value = 0.3; 
                            panner.connect(send);
                            send.connect(this.convolver);
                        }
                        return panner;
                    }
                };

                // å…¨å±€å±‚ï¼šç©ºæ°”åˆ‡å‰²å£° (Air Whoosh) - å¢åŠ çœŸå®æ„Ÿ
                // æ¨¡æ‹Ÿåˆ€åˆƒå¿«é€Ÿç©¿è¿‡ç©ºæ°”å¹¶æ¥è§¦ç‰©ä½“ç¬é—´çš„æ°”æµæ‰°åŠ¨
                const playAir = () => {
                    const air = this.audioCtx.createBufferSource();
                    air.buffer = this.buffers.white;
                    const aFilter = this.audioCtx.createBiquadFilter();
                    const aGain = this.audioCtx.createGain();

                    aFilter.type = 'bandpass';
                    aFilter.frequency.setValueAtTime(4000, t);
                    aFilter.frequency.linearRampToValueAtTime(8000, t + 0.1); // å¿«é€Ÿä¸Šæ‰«

                    aGain.gain.setValueAtTime(0.15 * volMod, t); // éŸ³é‡å¾ˆå°ï¼Œä½œä¸ºç‚¹ç¼€
                    aGain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);

                    air.connect(aFilter); aFilter.connect(aGain); aGain.connect(createChain(0));
                    air.start(t); air.stop(t + 0.15);
                };
                playAir(); // æ¯æ¬¡åˆ‡å‰²éƒ½æ’­æ”¾

                // --- é’ˆå¯¹ä¸åŒæ°´æœçš„ç‹¬ç«‹åˆæˆé…æ–¹ (Sound Recipes V6: Hyper-Realism) ---

                // 1. è¥¿ç“œ (Watermelon): æ¹¿æ¶¦çˆ†è£‚ + ä½é¢‘å†²å‡»
                const playWatermelon = () => {
                    // Layer A: æ¹¿æ¶¦çº¹ç† (Wet Texture)
                    const wet = this.audioCtx.createBufferSource();
                    wet.buffer = this.buffers.wet;
                    const wFilter = this.audioCtx.createBiquadFilter();
                    const wGain = this.audioCtx.createGain();

                    wFilter.type = 'lowpass';
                    wFilter.frequency.setValueAtTime(rand(500, 700), t); 
                    // å¢åŠ åŠ¨æ€ï¼šé¢‘ç‡éšæ—¶é—´ä¸‹é™ï¼Œæ¨¡æ‹Ÿåˆ€åˆƒåˆ‡å…¥åçš„é—·å£°
                    wFilter.frequency.linearRampToValueAtTime(200, t + 0.3 * tightMod);

                    wGain.gain.setValueAtTime(0, t);
                    wGain.gain.linearRampToValueAtTime(1.3 * volMod, t + 0.01); // æ›´çŒ›çƒˆçš„èµ·éŸ³
                    wGain.gain.exponentialRampToValueAtTime(0.01, t + 0.35 * tightMod);

                    const chain = createChain(0.25); 
                    wet.connect(wFilter); wFilter.connect(wGain); wGain.connect(chain);
                    wet.start(t); wet.stop(t + 0.4);

                    // Layer B: ä½é¢‘å†²å‡» (Thud)
                    const thud = this.audioCtx.createBufferSource();
                    thud.buffer = this.buffers.brown;
                    const tFilter = this.audioCtx.createBiquadFilter();
                    const tGain = this.audioCtx.createGain();

                    tFilter.type = 'lowpass';
                    tFilter.frequency.value = 100; // æ›´ä½æ²‰
                    
                    tGain.gain.setValueAtTime(1.2 * volMod, t);
                    tGain.gain.exponentialRampToValueAtTime(0.01, t + 0.25);

                    thud.connect(tFilter); tFilter.connect(tGain); tGain.connect(createChain(0.1)); // ç¨å¾®åŠ ç‚¹å¤±çœŸ
                    thud.start(t); thud.stop(t + 0.3);
                };

                // 2. è‹¹æœ/æ¢¨ (Apple/Pear): æåº¦æ¸…è„† + ç¬é—´æ–­è£‚
                const playApple = () => {
                    // Layer A: è„†è£‚çº¹ç† (Crunch Texture)
                    const crunch = this.audioCtx.createBufferSource();
                    crunch.buffer = this.buffers.crunch;
                    const cFilter = this.audioCtx.createBiquadFilter();
                    const cGain = this.audioCtx.createGain();

                    cFilter.type = 'highpass';
                    cFilter.frequency.value = rand(2000, 3000); 
                    
                    cGain.gain.setValueAtTime(0, t);
                    cGain.gain.linearRampToValueAtTime(1.8 * volMod, t + 0.002); // 2ms æé€Ÿèµ·éŸ³
                    cGain.gain.exponentialRampToValueAtTime(0.01, t + 0.1 * tightMod); // æçŸ­

                    // é«˜å¤±çœŸï¼
                    const chain = createChain(0.9); 
                    crunch.connect(cFilter); cFilter.connect(cGain); cGain.connect(chain);
                    crunch.start(t); crunch.stop(t + 0.15);

                    // Layer B: åˆ€é”‹ (Swish) - å¢å¼ºé«˜é¢‘
                    const swish = this.audioCtx.createBufferSource();
                    swish.buffer = this.buffers.white;
                    const sFilter = this.audioCtx.createBiquadFilter();
                    const sGain = this.audioCtx.createGain();
                    
                    sFilter.type = 'highpass';
                    sFilter.frequency.setValueAtTime(4000, t);
                    
                    sGain.gain.setValueAtTime(0.4 * volMod, t);
                    sGain.gain.exponentialRampToValueAtTime(0.01, t + 0.12);

                    swish.connect(sFilter); sFilter.connect(sGain); sGain.connect(createChain(0));
                    swish.start(t); swish.stop(t + 0.2);
                };

                // 3. æ¤°å­ (Coconut): ç¡¬å£³å…±æŒ¯ + å†…éƒ¨ç©ºè…”
                const playCoconut = () => {
                    // Layer A: å£³ä½“æ’å‡» (Shell Knock)
                    const knock = this.audioCtx.createBufferSource();
                    knock.buffer = this.buffers.crunch; 
                    const kFilter = this.audioCtx.createBiquadFilter();
                    const kGain = this.audioCtx.createGain();

                    kFilter.type = 'bandpass';
                    kFilter.frequency.value = rand(800, 1200);
                    kFilter.Q.value = 3.0;

                    kGain.gain.setValueAtTime(0, t);
                    kGain.gain.linearRampToValueAtTime(1.2 * volMod, t + 0.01);
                    kGain.gain.exponentialRampToValueAtTime(0.01, t + 0.15 * tightMod);

                    const chain = createChain(0.6);
                    knock.connect(kFilter); kFilter.connect(kGain); kGain.connect(chain);
                    knock.start(t); knock.stop(t + 0.2);

                    // Layer B: æ²‰é—·ä½é¢‘ (Thud)
                    const thud = this.audioCtx.createBufferSource();
                    thud.buffer = this.buffers.brown;
                    const tGain = this.audioCtx.createGain();
                    tGain.gain.setValueAtTime(0.9 * volMod, t);
                    tGain.gain.exponentialRampToValueAtTime(0.01, t + 0.2);
                    
                    const tFilter = this.audioCtx.createBiquadFilter();
                    tFilter.type = 'lowpass';
                    tFilter.frequency.value = 160;

                    thud.connect(tFilter); tFilter.connect(tGain); tGain.connect(createChain(0));
                    thud.start(t); thud.stop(t + 0.25);
                };

                // 4. æ©™å­ (Orange): æ±æ°´å››æº…
                const playOrange = () => {
                    // Layer A: æ±æ°´å–·æº… (Spray)
                    const wet = this.audioCtx.createBufferSource();
                    wet.buffer = this.buffers.wet;
                    const wFilter = this.audioCtx.createBiquadFilter();
                    const wGain = this.audioCtx.createGain();

                    wFilter.type = 'highpass'; 
                    wFilter.frequency.setValueAtTime(1000, t);
                    wFilter.frequency.linearRampToValueAtTime(3000, t + 0.15); 

                    wGain.gain.setValueAtTime(0, t);
                    wGain.gain.linearRampToValueAtTime(0.9 * volMod, t + 0.02);
                    wGain.gain.exponentialRampToValueAtTime(0.01, t + 0.25 * tightMod);

                    const chain = createChain(0.35);
                    wet.connect(wFilter); wFilter.connect(wGain); wGain.connect(chain);
                    wet.start(t); wet.stop(t + 0.3);
                };

                // 5. é¦™è•‰ (Banana): è½¯ç³¯ã€è‡´å¯†ã€æ— æ±æ°´
                const playBanana = () => {
                    // Layer A: æœè‚‰åˆ‡æ–­ (Soft Slice)
                    const flesh = this.audioCtx.createBufferSource();
                    flesh.buffer = this.buffers.pink;
                    const fFilter = this.audioCtx.createBiquadFilter();
                    const fGain = this.audioCtx.createGain();

                    fFilter.type = 'lowpass';
                    fFilter.frequency.setValueAtTime(600, t); 
                    
                    fGain.gain.setValueAtTime(0, t);
                    fGain.gain.linearRampToValueAtTime(1.0 * volMod, t + 0.01);
                    fGain.gain.exponentialRampToValueAtTime(0.01, t + 0.15 * tightMod); 

                    const chain = createChain(0.65); 
                    flesh.connect(fFilter); fFilter.connect(fGain); fGain.connect(chain);
                    flesh.start(t); flesh.stop(t + 0.2);

                    // Layer B: æçŸ­çš„é«˜é¢‘ (Skin Snap)
                    const skin = this.audioCtx.createBufferSource();
                    skin.buffer = this.buffers.white;
                    const sFilter = this.audioCtx.createBiquadFilter();
                    const sGain = this.audioCtx.createGain();

                    sFilter.type = 'highpass';
                    sFilter.frequency.value = 3000;

                    sGain.gain.setValueAtTime(0.4 * volMod, t);
                    sGain.gain.exponentialRampToValueAtTime(0.01, t + 0.05); 

                    skin.connect(sFilter); sFilter.connect(sGain); sGain.connect(createChain(0));
                    skin.start(t); skin.stop(t + 0.1);
                };

                // è°ƒåº¦å™¨ï¼šæ ¹æ®æ°´æœç±»å‹é€‰æ‹©ä¸åŒçš„åˆæˆé…æ–¹
                switch (fruit.type) {
                    case 'watermelon': playWatermelon(); break;
                    case 'apple': 
                    case 'pear': playApple(); break;
                    case 'coconut': playCoconut(); break;
                    case 'orange': playOrange(); break;
                    case 'banana': playBanana(); break;
                    default: playApple();
                }
            }

            playBombSound() {
                if (!this.audioCtx) return;
                const t = this.audioCtx.currentTime;

                // ç‚¸å¼¹éŸ³æ•ˆ V2: æåº¦ç‚¸è£‚ (Hyper-Explosive)
                // æ ¸å¿ƒæ€è·¯ï¼šå¤šå±‚å åŠ  + å¼ºåŠ›å¤±çœŸ + åŠ¨æ€æ»¤æ³¢

                // è¾…åŠ©ï¼šåˆ›å»ºå¤±çœŸé“¾è·¯
                const createDistortionChain = (amount) => {
                    if (!this.distortionCurve) return this.audioCtx.destination;
                    const shaper = this.audioCtx.createWaveShaper();
                    shaper.curve = this.distortionCurve;
                    shaper.oversample = '4x';
                    const gain = this.audioCtx.createGain();
                    gain.gain.value = amount; // å¤±çœŸåçš„éŸ³é‡è¡¥å¿
                    shaper.connect(gain);
                    gain.connect(this.audioCtx.destination);
                    return shaper;
                };

                const distChain = createDistortionChain(0.6); // 60% å¤±çœŸæ··åˆ
                const cleanChain = this.audioCtx.destination;

                // 1. å†²å‡»æ³¢ (Shockwave) - æé€Ÿä¸‹æ½œçš„ä¸‰è§’æ³¢
                // æ¨¡æ‹Ÿçˆ†ç‚¸ç¬é—´çš„ç©ºæ°”å‹ç¼©
                const osc = this.audioCtx.createOscillator();
                const oscGain = this.audioCtx.createGain();
                osc.type = 'triangle'; // ä¸‰è§’æ³¢æ³›éŸ³æ›´ä¸°å¯Œï¼Œå¤±çœŸåæ›´å‡¶çŒ›
                osc.frequency.setValueAtTime(800, t); 
                osc.frequency.exponentialRampToValueAtTime(40, t + 0.15); // æé€Ÿä¸‹æ½œ
                osc.frequency.linearRampToValueAtTime(10, t + 0.8); // ç¼“æ…¢ä½™éœ‡

                oscGain.gain.setValueAtTime(1.2, t); // è¶…å¤§éŸ³é‡
                oscGain.gain.exponentialRampToValueAtTime(0.01, t + 0.8);

                osc.connect(oscGain);
                oscGain.connect(distChain); // è¿›å¤±çœŸ
                osc.start(t); osc.stop(t + 0.8);

                // 2. çˆ†ç‚¸ç«å…‰ (Fireball) - åŠ¨æ€ä½é€šç™½å™ª
                // æ¨¡æ‹Ÿç«ç„°è†¨èƒ€çš„å£°éŸ³
                const noise = this.audioCtx.createBufferSource();
                noise.buffer = this.buffers.white;
                const nFilter = this.audioCtx.createBiquadFilter();
                const nGain = this.audioCtx.createGain();

                nFilter.type = 'lowpass';
                nFilter.frequency.setValueAtTime(4000, t); // åˆå§‹é«˜é¢‘
                nFilter.frequency.exponentialRampToValueAtTime(100, t + 0.5); // è¿…é€Ÿå˜é—·

                nGain.gain.setValueAtTime(1.0, t);
                nGain.gain.exponentialRampToValueAtTime(0.01, t + 0.6);

                noise.connect(nFilter); nFilter.connect(nGain); nGain.connect(distChain); // è¿›å¤±çœŸ
                noise.start(t); noise.stop(t + 0.6);

                // 3. ç¢ç‰‡é£æº… (Debris) - é«˜é€š Crunch
                // æ¨¡æ‹Ÿå¤–å£³ç‚¸ç¢çš„å£°éŸ³ï¼Œä¸è¿›å¤±çœŸä»¥ä¿æŒæ¸…è„†
                const debris = this.audioCtx.createBufferSource();
                debris.buffer = this.buffers.crunch;
                const dFilter = this.audioCtx.createBiquadFilter();
                const dGain = this.audioCtx.createGain();

                dFilter.type = 'highpass';
                dFilter.frequency.value = 2000;

                dGain.gain.setValueAtTime(0, t);
                dGain.gain.linearRampToValueAtTime(0.8, t + 0.05); // ç¨æ™šä¸€ç‚¹å‡ºç°
                dGain.gain.exponentialRampToValueAtTime(0.01, t + 0.7);

                debris.connect(dFilter); dFilter.connect(dGain); dGain.connect(cleanChain); 
                debris.start(t); debris.stop(t + 0.7);
            }

            playGameOverSound() {
                if (!this.audioCtx) return;
                const t = this.audioCtx.currentTime;
                
                // æ¸¸æˆç»“æŸï¼šæ·±æ²‰çš„æ‰“å‡»å£° (Gong-like)
                const src = this.audioCtx.createBufferSource();
                src.buffer = this.buffers.brown;
                const filter = this.audioCtx.createBiquadFilter();
                const gain = this.audioCtx.createGain();
                
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(300, t);
                filter.frequency.exponentialRampToValueAtTime(50, t + 1.5);
                
                gain.gain.setValueAtTime(0.8, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 1.5);
                
                src.connect(filter);
                filter.connect(gain);
                gain.connect(this.audioCtx.destination);
                
                src.start(t);
                src.stop(t + 2.0);
            }

            resize() {
                const vv = window.visualViewport;
                this.width = vv ? vv.width : window.innerWidth;
                this.height = vv ? vv.height : window.innerHeight;
                this.canvas.width = this.width;
                this.canvas.height = this.height;
                this.updateVideoLayout();
            }

            updateVideoLayout() {
                if (this.video.readyState < 2) return;

                const vw = this.video.videoWidth;
                const vh = this.video.videoHeight;
                this.videoDims = { vw, vh };
                const cw = this.width;
                const ch = this.height;
                // Cover é€‚é…ï¼šå¡«æ»¡å±å¹•ï¼Œå¿…è¦æ—¶è£å‰ªï¼›è¯†åˆ«ä»åŸºäºåŸå§‹è§†é¢‘å°ºå¯¸
                const scale = Math.max(cw / vw, ch / vh);
                const drawW = vw * scale;
                const drawH = vh * scale;
                const offsetX = (cw - drawW) / 2;
                const offsetY = (ch - drawH) / 2;

                this.videoMapping = { scale, offsetX, offsetY, drawW, drawH };
            }

    async initMediaPipe() {
        if (typeof Hands === 'undefined') {
            this.ui.status.innerText = "MediaPipe åº“åŠ è½½å¤±è´¥";
            this.ui.loadingMsg.innerHTML = `<p style="color:red">æ— æ³•åŠ è½½ MediaPipe æ ¸å¿ƒåº“ã€‚<br>è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–åˆ·æ–°é¡µé¢ã€‚</p>`;
            return;
        }

        // è‡ªåŠ¨æ£€æµ‹æœ¬åœ°æ¨¡å‹æ–‡ä»¶å®Œæ•´æ€§
        // ç§»åŠ¨ç«¯ä¼˜å…ˆ Liteï¼Œæ¡Œé¢ä½¿ç”¨ Fullï¼›ç¼ºå¤±åˆ™åˆ‡æ¢ CDN
        if (this.currentCdnIndex === 0) {
            const prefer = this.isMobile
                ? ['hand_landmark_lite.tflite']
                : ['hand_landmark_full.tflite'];
            let foundLocal = false;

            for (const candidate of prefer) {
                try {
                    console.log(`Checking local model availability: ${candidate}...`);
                    const response = await fetch(`hands/${candidate}`, { method: 'HEAD' });
                    if (response.ok) {
                        this.modelFile = candidate;
                        foundLocal = true;
                        break;
                    }
                } catch (e) {
                    console.warn(`Failed to check local model file ${candidate}.`, e);
                }
            }

            if (!foundLocal) {
                console.warn(`Local model file missing. Switching to Online CDN.`);
                this.currentCdnIndex = 1; // Switch to JSDelivr
                this.modelFile = this.isMobile ? 'hand_landmark_lite.tflite' : 'hand_landmark_full.tflite';
            }
        } else {
            // éæœ¬åœ°æ¨¡å¼æŒ‰å¹³å°ä¼˜å…ˆçº§
            this.modelFile = this.isMobile ? 'hand_landmark_lite.tflite' : 'hand_landmark_full.tflite';
        }

        const cdn = this.cdnList[this.currentCdnIndex];
        const statusLines = {};
        const renderStatus = () => {
            const text = Object.values(statusLines).join('\n') || '...';
            this.ui.status.innerText = text;
            const p = this.ui.loadingMsg.querySelector('p');
            if (p) p.innerText = text;
        };
        const updateStatus = (msg, key = null) => {
            if (key) {
                statusLines[key] = msg;
                renderStatus();
            } else {
                statusLines['_global'] = msg;
                renderStatus();
            }
        };

        // é¢„å–æ¨¡å‹/wasmå¹¶æ˜¾ç¤ºç™¾åˆ†æ¯”è¿›åº¦ï¼ˆå¹¶è¡Œä¸‹è½½ï¼‰
        const blobUrlMap = {};
        // é¢„æœŸå¤§å°è¡¨ï¼Œç”¨äºå±•ç¤ºæ›´æ¥è¿‘å®é™…çš„ä½“ç§¯ï¼ˆéƒ¨åˆ† CDN ä¼šå‹ç¼©ä¼ è¾“å¯¼è‡´ Content-Length åå°ï¼‰
        const expectedSizes = {
            'hand_landmark_full.tflite': 5.22,
            'hand_landmark_lite.tflite': 1.98,
            'hands_solution_packed_assets_loader.js': 0.01,
            'hands_solution_packed_assets.data': 4.13,
            'hands_solution_simd_wasm_bin.js': 0.26,
            'hands_solution_simd_wasm_bin.wasm': 5.75,
            'hands.binarypb': 0.01
        };

        const prefetchWithProgress = async (file, label, required = true) => {
            const url = `${cdn.url}${file}`;
            const res = await fetch(url);
            if (!res.ok) {
                if (!required) {
                    updateStatus(`${label}: è·³è¿‡ (${res.status})`, file);
                    return;
                }
                throw new Error(`${label} è·å–å¤±è´¥ (${res.status})`);
            }
            const total = Number(res.headers.get('content-length')) || 0;
            const reader = res.body.getReader();
            let loaded = 0;
            const chunks = [];
            while (true) {
                const { done, value } = await reader.read();
                if (done) break;
                chunks.push(value);
                loaded += value.byteLength;
                const loadedMB = (loaded / 1048576).toFixed(2);
                const expectedMB = expectedSizes[file];
                if (total) {
                    const pct = (loaded / total * 100).toFixed(1);
                    const totalMB = (total / 1048576).toFixed(2);
                    updateStatus(`${label}: ${pct}% (${loadedMB}MB/${totalMB}MB)`, file);
                } else if (expectedMB) {
                    updateStatus(`${label}: ${loadedMB}MB / ~${expectedMB.toFixed(2)}MB`, file);
                } else {
                    updateStatus(`${label}: ${loadedMB}MB`, file);
                }
            }
            const blob = new Blob(chunks);
            blobUrlMap[file] = URL.createObjectURL(blob);
            const finalMB = (loaded / 1048576).toFixed(2);
            const suffix = expectedSizes[file] ? ` (~${expectedSizes[file].toFixed(2)}MB)` : '';
            updateStatus(`${label}: å®Œæˆ (${finalMB}MB${suffix})`, file);
        };

        // éœ€è¦æ˜¾ç¤ºè¿›åº¦çš„æ ¸å¿ƒæ–‡ä»¶ï¼ˆå¯æŒ‰éœ€æ‰©å±•ï¼‰
        const assetFiles = this.isMobile
            ? [
                { file: 'hand_landmark_lite.tflite', label: 'hand_landmark_lite.tflite', required: true },
                { file: 'hands_solution_packed_assets.data', label: 'hands_solution_packed_assets.data', required: true },
                { file: 'hands_solution_packed_assets_loader.js', label: 'hands_solution_packed_assets_loader.js', required: true },
                { file: 'hands_solution_simd_wasm_bin.js', label: 'hands_solution_simd_wasm_bin.js', required: true },
                { file: 'hands_solution_simd_wasm_bin.wasm', label: 'hands_solution_simd_wasm_bin.wasm', required: false },
                { file: 'hands.binarypb', label: 'hands.binarypb', required: true }
            ]
            : [
                { file: 'hand_landmark_full.tflite', label: 'hand_landmark_full.tflite (~5.2MB)', required: true },
                { file: 'hands_solution_packed_assets.data', label: 'hands_solution_packed_assets.data', required: true },
                { file: 'hands_solution_packed_assets_loader.js', label: 'hands_solution_packed_assets_loader.js', required: true },
                { file: 'hands_solution_simd_wasm_bin.js', label: 'hands_solution_simd_wasm_bin.js', required: true },
                { file: 'hands_solution_simd_wasm_bin.wasm', label: 'hands_solution_simd_wasm_bin.wasm', required: false },
                { file: 'hands.binarypb', label: 'hands.binarypb', required: true }
            ];

        updateStatus(`åˆå§‹åŒ– MediaPipe (${cdn.name})...`);
        console.log(`Using CDN: ${cdn.url}`);

        // å¹¶è¡Œé¢„å–ï¼›å¤±è´¥åˆ™å›é€€ä¸ºç›´æ¥åŠ è½½
        try {
            const tasks = assetFiles.map(({ file, label, required }) => prefetchWithProgress(file, `åŠ è½½ ${label}`, required));
            await Promise.all(tasks);
            updateStatus('æ¨¡å‹æ–‡ä»¶å·²ç¼“å­˜ï¼Œæ­£åœ¨åˆå§‹åŒ–...');
        } catch (e) {
            console.warn('é¢„å–æ¨¡å‹/wasm å¤±è´¥ï¼Œæ”¹ç”¨ç›´æ¥åŠ è½½', e);
            Object.keys(blobUrlMap).forEach(k => URL.revokeObjectURL(blobUrlMap[k]));
            Object.keys(blobUrlMap).forEach(k => delete blobUrlMap[k]);
        }

        const hands = new Hands({
            locateFile: (file) => {
                if (blobUrlMap[file]) return blobUrlMap[file];
                return `${cdn.url}${file}`;
            }
        });

                const modelComplexity = (this.modelFile && this.modelFile.includes('lite')) ? 0 : 1;
                hands.setOptions({
                    maxNumHands: 2,
                    modelComplexity,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });

                hands.onResults((results) => this.onHandsResults(results));
                this.hands = hands;

                try {
                    updateStatus("æ­£åœ¨åŠ è½½æ¨¡å‹æ–‡ä»¶(è¯·è€å¿ƒç­‰å¾…)...");

                    // æ·»åŠ è¶…æ—¶æ§åˆ¶ (å»¶é•¿è‡³ 9 åˆ†é’Ÿ) å¹¶æ˜¾ç¤ºåŠ è½½è®¡æ—¶
                    const loadPromise = hands.initialize();
                    const timeoutMs = 540000; // 9 åˆ†é’Ÿ
                    const startTime = Date.now();
                    const progressTimer = setInterval(() => {
                        const elapsedSec = Math.floor((Date.now() - startTime) / 1000);
                        updateStatus(`æ­£åœ¨åŠ è½½æ¨¡å‹... ${elapsedSec}s`);
                    }, 1000);
                    const hangWarn = setTimeout(() => {
                        updateStatus('åˆå§‹åŒ–è€—æ—¶è¾ƒé•¿ï¼Œå¯èƒ½è¢«ç½‘ç»œæˆ–æµè§ˆå™¨é˜»å¡ï¼Œå»ºè®®å°è¯•åˆ‡æ¢çº¿è·¯æˆ–åˆ·æ–°');
                    }, 45000);

                    const timeoutPromise = new Promise((_, reject) =>
                        setTimeout(() => reject(new Error(`æ¨¡å‹åŠ è½½è¶…æ—¶ (${timeoutMs / 1000}s)`)), timeoutMs)
                    );

                    await Promise.race([loadPromise, timeoutPromise]);
                    clearInterval(progressTimer);
                    clearTimeout(hangWarn);

                    updateStatus("è¯·æ±‚æ‘„åƒå¤´æƒé™...");
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: this.isMobile
                            ? { width: 960, height: 540, facingMode: "user" }
                            : { width: 1280, height: 720, facingMode: "user" }
                    });

                    updateStatus("ç­‰å¾…æ‘„åƒå¤´ç”»é¢...");
                    this.video.srcObject = stream;
                    await new Promise((resolve) => {
                        this.video.onloadedmetadata = () => {
                            this.updateVideoLayout();
                            this.video.play();
                            resolve();
                        };
                    });

                    this.ui.loadingMsg.classList.add('hidden');
                    this.ui.startMenu.classList.remove('hidden');
                    this.state = 'MENU';
                    updateStatus("ç³»ç»Ÿå°±ç»ª");

                    // Start processing loop
                    this.processVideo();
                    this.loop();
                } catch (e) {
                    console.error("Init error:", e);
                    updateStatus("åˆå§‹åŒ–å¤±è´¥");

                    // æ„å»ºé‡è¯•æŒ‰é’®
                    let nextCdnIndex = (this.currentCdnIndex + 1) % this.cdnList.length;
                    let nextCdnName = this.cdnList[nextCdnIndex].name;

                    // è‡ªåŠ¨é‡è¯•é€»è¾‘ï¼šå¦‚æœä¸æ˜¯æœ€åä¸€æ¡çº¿è·¯ï¼Œä¸”æ˜¯è¶…æ—¶é”™è¯¯ï¼Œå°è¯•è‡ªåŠ¨åˆ‡æ¢
                    // ä½†ä¸ºäº†é¿å…æ­»å¾ªç¯ï¼Œè¿™é‡Œè¿˜æ˜¯è®©ç”¨æˆ·æ‰‹åŠ¨ç‚¹æ¯”è¾ƒå®‰å…¨ï¼Œæˆ–è€…å€’è®¡æ—¶è‡ªåŠ¨ç‚¹

                    this.ui.loadingMsg.innerHTML = `
                <p style="color:red; font-size: 18px;">åˆå§‹åŒ–å¤±è´¥: ${e.message}</p>
                <p style="font-size: 14px; color: #aaa;">å½“å‰çº¿è·¯: ${cdn.name}</p>
                <button onclick="game.switchCdnAndRetry()" style="font-size: 16px; padding: 10px 20px; margin-top: 10px;">
                    åˆ‡æ¢åˆ° ${nextCdnName} é‡è¯•
                </button>
                <div style="margin-top: 15px; font-size: 12px; text-align: left; background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px;">
                    <strong>è§£å†³æ–¹æ¡ˆï¼š</strong><br>
                    1. ç‚¹å‡»ä¸Šæ–¹æŒ‰é’®åˆ‡æ¢çº¿è·¯é‡è¯•ã€‚<br>
                    2. æ£€æŸ¥ç½‘ç»œè¿æ¥ (å¯èƒ½éœ€è¦ç§‘å­¦ä¸Šç½‘)ã€‚<br>
                    3. å¦‚æœä¸€ç›´å¤±è´¥ï¼Œè¯·å°è¯•æ‰‹åŠ¨ä¸‹è½½æ¨¡å‹æ–‡ä»¶åˆ°æœ¬åœ° <code>hands</code> æ–‡ä»¶å¤¹ã€‚
                </div>
            `;
                }
            }

            switchCdnAndRetry() {
                this.currentCdnIndex = (this.currentCdnIndex + 1) % this.cdnList.length;
                this.ui.loadingMsg.innerHTML = `<div class="loader"></div><p>æ­£åœ¨åˆ‡æ¢çº¿è·¯é‡è¯•...</p>`;
                // æ¸…ç†æ—§çš„ hands å®ä¾‹ (è™½ç„¶ JS æ— æ³•å®Œå…¨å¼ºåˆ¶é”€æ¯ï¼Œä½†æˆ‘ä»¬å¯ä»¥é‡æ–°èµ‹å€¼)
                if (this.hands) {
                    try { this.hands.close(); } catch (e) { }
                }
                this.initMediaPipe();
            }

            async processVideo() {
                if (this.video.readyState >= 2) {
                    const now = Date.now();
                    // å¸§ç‡é™åˆ¶ (Throttling)
                    if (now - this.lastDetectionTime >= this.detectionInterval) {
                        this.lastDetectionTime = now;
                        try {
                            await this.hands.send({ image: this.video });
                        } catch (e) {
                            console.error("MediaPipe processing error:", e);
                            this.ui.status.innerText = "æ¨¡å‹å¤„ç†å‡ºé”™";
                        }
                    }
                }
                requestAnimationFrame(() => this.processVideo());
            }

            onHandsResults(results) {
                // é•œåƒå¤„ç†ï¼šMediaPipeè¾“å‡ºçš„åæ ‡æ˜¯å½’ä¸€åŒ–çš„ï¼Œä¸”é€šå¸¸æ˜¯é•œåƒçš„
                // æˆ‘ä»¬åœ¨ç»˜åˆ¶æ—¶ä¼šç¿»è½¬Canvasï¼Œæ‰€ä»¥è¿™é‡Œç›´æ¥ä¿å­˜æ•°æ®
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    this.handLandmarks = results.multiHandLandmarks;
                    this.detectGestures(results.multiHandLandmarks, results.multiHandedness);
                } else {
                    this.handLandmarks = null;
                    this.gestureState = 'NONE';
                    this.ui.status.innerText = "æœªæ£€æµ‹åˆ°æ‰‹";
                }
            }

            detectGestures(landmarksList, handedness) {
                const now = Date.now();

                // å€’è®¡æ—¶é˜¶æ®µä¸å¤„ç†æ‰‹åŠ¿ï¼Œé¿å…è¯¯è§¦é‡ç½®/æš‚åœå¯¼è‡´å›åˆ°å¼€å§‹ç•Œé¢
                if (this.state === 'COUNTDOWN') {
                    this.gestureState = 'NONE';
                    this.gestureStartTime = null;
                    this.ui.status.innerText = 'å€’è®¡æ—¶ä¸­...';
                    return;
                }

                // å†·å´æ—¶é—´æ£€æŸ¥ (é˜²æ­¢è¿ç»­è§¦å‘) - 3ç§’å€’è®¡æ—¶
                const cooldownDuration = 3000;
                const timeSinceLastAction = now - this.lastActionTime;

                if (timeSinceLastAction < cooldownDuration) {
                    const remainingSeconds = Math.ceil((cooldownDuration - timeSinceLastAction) / 1000);

                    this.gestureState = 'COOLDOWN';
                    this.gestureStartTime = null;

                    // ä»…åœ¨é COUNTDOWN çŠ¶æ€ä¸‹æ˜¾ç¤ºå€’è®¡æ—¶ (é¿å…ä¸å¼€å§‹æ¸¸æˆå€’è®¡æ—¶å†²çª)
                    if (this.state !== 'COUNTDOWN') {
                        this.ui.countdownDisplay.classList.remove('hidden');
                        this.ui.countdownDisplay.innerText = remainingSeconds;
                        this.ui.countdownDisplay.style.color = '#ffeb3b'; // é»„è‰²è­¦å‘Šè‰²
                        this.ui.status.innerText = `â³ å†·å´ä¸­... ${remainingSeconds}`;

                        // æ’­æ”¾å€’è®¡æ—¶éŸ³æ•ˆ
                        if (this.lastCooldownSec !== remainingSeconds) {
                            this.playCountdownSound(remainingSeconds);
                            this.lastCooldownSec = remainingSeconds;
                        }
                    }
                    return;
                } else {
                    // å†·å´ç»“æŸï¼Œéšè—å€’è®¡æ—¶
                    if (this.state !== 'COUNTDOWN' && !this.ui.countdownDisplay.classList.contains('hidden')) {
                        this.ui.countdownDisplay.classList.add('hidden');
                        this.ui.countdownDisplay.style.color = ''; // é‡ç½®é¢œè‰²
                    }
                    this.lastCooldownSec = 0;
                }

                // 1. åˆ†ææ¯ä¸€åªæ‰‹çš„çŠ¶æ€
                this.handStates = landmarksList.map(hand => this.analyzeHandPose(hand));

                // 2. å…¨å±€æ‰‹åŠ¿åˆ¤å®š (æš‚åœ/é‡å¼€)
                let globalState = 'PLAYING';
                let statusText = '';

                // æ£€æŸ¥æ˜¯å¦åŒæ‰‹å¼ å¼€ (é‡ç½®)
                if (this.handStates.length === 2 && this.handStates[0] === 'OPEN_PALM' && this.handStates[1] === 'OPEN_PALM') {
                    globalState = 'TWO_HANDS_OPEN';
                    statusText = 'ğŸ‘ ä¿æŒåŒæ‰‹å¼ å¼€ä»¥é‡ç½®...';
                }
                // æ£€æŸ¥æ˜¯å¦æœ‰æ‰‹å¼ å¼€ (æš‚åœ)
                else if (this.handStates.includes('OPEN_PALM')) {
                    // åªæœ‰åœ¨æ¸¸æˆè¿›è¡Œä¸­æˆ–æš‚åœæ—¶æ‰å…è®¸è§¦å‘æš‚åœ/ç»§ç»­
                    if (this.state === 'PLAYING' || this.state === 'PAUSED') {
                        globalState = 'OPEN_PALM';
                        statusText = this.state === 'PLAYING' ? 'ğŸ–ï¸ ä¿æŒå¼ æ‰‹ä»¥æš‚åœ...' : 'ğŸ–ï¸ ä¿æŒå¼ æ‰‹ä»¥ç»§ç»­...';
                    } else {
                        // åœ¨ GAMEOVER æˆ– COUNTDOWN çŠ¶æ€ä¸‹ï¼Œå•æ‰‹å¼ å¼€è§†ä¸ºæ™®é€šçŠ¶æ€
                        statusText = 'ğŸ”ª åˆ‡å‰²æ¨¡å¼';
                    }
                }
                else if (this.handStates.includes('FIST')) {
                    statusText = 'âœŠ é˜²å¾¡æ¨¡å¼';
                }
                else {
                    statusText = 'ğŸ”ª åˆ‡å‰²æ¨¡å¼';
                }

                // çŠ¶æ€åˆ‡æ¢æ—¶é‡ç½®è®¡æ—¶å™¨ (é˜²æ­¢ä»æš‚åœæ‰‹åŠ¿æ»‘å‘é‡ç½®æ‰‹åŠ¿æ—¶ç»§æ‰¿æ—¶é—´)
                if (globalState !== this.gestureState) {
                    this.gestureStartTime = null;
                }

                this.gestureState = globalState;
                this.ui.status.innerText = statusText;

                // å¤„ç†æ‰‹åŠ¿æŒç»­æ—¶é—´è§¦å‘çš„äº‹ä»¶

                // é‡ç½®é€»è¾‘ï¼šå¿…é¡»æ˜¯åŒæ‰‹å¼ å¼€
                if (globalState === 'TWO_HANDS_OPEN') {
                    if (!this.gestureStartTime) this.gestureStartTime = now;
                    // å¢åŠ åˆ° 1.5 ç§’ (1500ms)
                    if (now - this.gestureStartTime > 1500) {
                        this.restartGame();
                        this.gestureStartTime = null;
                        this.lastActionTime = now; // è®¾ç½®å†·å´
                    }
                }
                // æš‚åœé€»è¾‘ï¼šå•æ‰‹å¼ å¼€å³å¯ï¼Œä½†å¦‚æœæ­£åœ¨è¿›è¡ŒåŒæ‰‹é‡ç½®ï¼Œåˆ™ä¸è§¦å‘æš‚åœ
                else if (globalState === 'OPEN_PALM') {
                    if (!this.gestureStartTime) this.gestureStartTime = now;
                    if (now - this.gestureStartTime > 2000) { // 2ç§’è§¦å‘
                        this.togglePause();
                        this.gestureStartTime = null; // é‡ç½®é˜²æ­¢é‡å¤è§¦å‘
                        this.lastActionTime = now; // è®¾ç½®å†·å´
                    }
                } else {
                    this.gestureStartTime = null;
                }
            }

            analyzeHandPose(landmarks) {
                const isFingerExtended = (lm, fingerTipIdx, fingerPipIdx) => {
                    const wrist = lm[0];
                    const tip = lm[fingerTipIdx];
                    const pip = lm[fingerPipIdx];
                    return Math.hypot(tip.x - wrist.x, tip.y - wrist.y) >
                        Math.hypot(pip.x - wrist.x, pip.y - wrist.y) * 1.1;
                };

                const indexExtended = isFingerExtended(landmarks, 8, 6);
                const middleExtended = isFingerExtended(landmarks, 12, 10);
                const ringExtended = isFingerExtended(landmarks, 16, 14);
                const pinkyExtended = isFingerExtended(landmarks, 20, 18);
                const thumbExtended = isFingerExtended(landmarks, 4, 2);

                if (indexExtended && middleExtended && ringExtended && pinkyExtended && thumbExtended) {
                    return 'OPEN_PALM';
                } else if (!indexExtended && !middleExtended && !ringExtended && !pinkyExtended) {
                    return 'FIST';
                } else {
                    return 'SLICE';
                }
            }

            applyDifficultyRamp(tSec) {
                const r = this.difficultyRamp;
                const p = Math.min(1, Math.max(0, tSec / r.duration));
                const lerp = (a, b) => a + (b - a) * p;

                this.difficultyBase = lerp(r.difficultyBaseEasy, r.difficultyBaseHard);
                this.apexMinFactor = lerp(r.apexMinEasy, r.apexMinHard);
                this.apexMaxFactor = lerp(r.apexMaxEasy, r.apexMaxHard);
                this.specialScale = lerp(r.specialScaleEasy, r.specialScaleHard);
                this.burstScale = lerp(r.burstScaleEasy, r.burstScaleHard);

                const spawnRate = lerp(r.spawnEasy, r.spawnHard);
                const spawnFloor = lerp(r.floorEasy, r.floorHard);
                const maxFruits = lerp(r.maxEasy, r.maxHard);

                this.spawnRateInitial = this.isMobile ? spawnRate + 10 : spawnRate;
                this.spawnRateFloor = this.isMobile ? Math.max(18, spawnFloor) : Math.max(22, spawnFloor);
                this.maxFruits = this.isMobile ? Math.min(maxFruits, 14) : Math.round(maxFruits);
            }

            startGame() {
                this.lastActionTime = Date.now(); // é‡ç½®å†·å´æ—¶é—´
                if (this.audioCtx && this.audioCtx.state === 'suspended') {
                    this.audioCtx.resume();
                }
                this.ui.menuOverlay.classList.add('hidden');
                this.ui.startMenu.classList.add('hidden');
                this.ui.gameOverMenu.classList.add('hidden');
                this.ui.pauseMenu.classList.add('hidden');

                this.state = 'COUNTDOWN';
                this.ui.countdownDisplay.classList.remove('hidden');

                let count = 3;
                this.ui.countdownDisplay.innerText = count;

                const timer = setInterval(() => {
                    count--;
                    if (count > 0) {
                        this.ui.countdownDisplay.innerText = count;
                    } else if (count === 0) {
                        this.ui.countdownDisplay.innerText = 'GO!';
                    } else {
                        clearInterval(timer);
                        this.ui.countdownDisplay.classList.add('hidden');
                        this.startPlaying();
                    }
                }, 1000);
            }

            startPlaying() {
                this.state = 'PLAYING';
                this.score = 0;
                this.lives = 3;
                this.gameTime = 0;
                this.lastDisplayedTime = -1;
                this.fruits = [];
                this.particles = [];
                this.applyDifficultyRamp(0);
                this.difficultyMultiplier = this.difficultyBase;
                this.startTime = Date.now();
                this.pauseStartTime = null;
                this.missedFruits = 0;
                this.slicedFruitsTotal = 0;
                this.doubleScoreTimer = 0;
                this.updateHUD();
            }

            togglePause() {
                this.lastActionTime = Date.now(); // é‡ç½®å†·å´æ—¶é—´
                if (this.state === 'PLAYING') {
                    this.state = 'PAUSED';
                    this.ui.menuOverlay.classList.remove('hidden');
                    this.ui.pauseMenu.classList.remove('hidden');
                    this.pauseStartTime = Date.now();
                } else if (this.state === 'PAUSED') {
                    this.resumeGame();
                }
            }

            resumeGame() {
                this.lastActionTime = Date.now(); // é‡ç½®å†·å´æ—¶é—´
                if (this.pauseStartTime) {
                    // å°†æš‚åœè€—æ—¶ä»æ¸¸æˆè®¡æ—¶ä¸­æ‰£é™¤
                    this.startTime += (Date.now() - this.pauseStartTime);
                    this.pauseStartTime = null;
                }
                this.state = 'PLAYING';
                this.ui.menuOverlay.classList.add('hidden');
                this.ui.pauseMenu.classList.add('hidden');
            }

            restartGame() {
                this.startGame();
            }

            gameOver(reason = "ç”Ÿå‘½å€¼è€—å°½") {
                this.playGameOverSound();
                this.state = 'GAMEOVER';
                if (this.score > this.highScore) {
                    this.highScore = this.score;
                    localStorage.setItem('fruit_ninja_highscore', this.highScore);
                }
                this.ui.finalScore.innerText = this.score;
                
                // æ˜¾ç¤ºç»“æŸåŸå› 
                let reasonEl = document.getElementById('game-over-reason');
                if (!reasonEl) {
                    reasonEl = document.createElement('p');
                    reasonEl.id = 'game-over-reason';
                    reasonEl.style.color = '#ff5252';
                    reasonEl.style.fontSize = '24px';
                    reasonEl.style.fontWeight = 'bold';
                    reasonEl.style.margin = '10px 0';
                    // æ’å…¥åˆ°åˆ†æ•°ä¸‹æ–¹
                    const scoreP = this.ui.gameOverMenu.querySelector('p');
                    if(scoreP) scoreP.after(reasonEl);
                }
                reasonEl.innerText = reason;

                this.ui.menuOverlay.classList.remove('hidden');
                this.ui.gameOverMenu.classList.remove('hidden');
            }

            spawnFruit() {
                // ç‰¹æ®Šç‰©å“æ¦‚ç‡éšæ—¶é—´ç•¥å‡ï¼Œå¼€å±€æ›´å®½æ¾
                const specialBase = 0.10 * this.specialScale;
                const isSpecial = Math.random() < Math.min(0.18 * this.specialScale, specialBase + this.difficultyMultiplier * 0.03 * this.specialScale);
                let item;

                if (isSpecial) {
                    const rand = Math.random();
                    let cumulativeWeight = 0;
                    // ç®€å•çš„æƒé‡é€‰æ‹©
                    if (rand < 0.7) item = SPECIAL_ITEMS[0]; // Bomb
                    else item = SPECIAL_ITEMS[1]; // Ice
                } else {
                    item = FRUIT_TYPES[Math.floor(Math.random() * FRUIT_TYPES.length)];
                }

                const x = Math.random() * (this.width - 100) + 50;
                const y = this.height + 50;
                // ç¨å¾®å‘å±å¹•ä¸­å¿ƒæŠ›å°„
                const centerX = this.width / 2;

                // éšæœºå¤§å°å˜åŒ– (0.8 ~ 1.3å€)
                const sizeVariation = 0.8 + Math.random() * 0.5;
                const finalSize = item.size * sizeVariation;

                // éšæœºé€Ÿåº¦å˜åŒ–
                const vx = (centerX - x) * 0.012 + (Math.random() - 0.5) * 5; // é™ä½æ°´å¹³é€Ÿåº¦
                // è®¡ç®—å¸Œæœ›ä¸Šå‡åˆ°ç”»å¸ƒ (apexMin~apexMax) é«˜åº¦ï¼Œå†è½ä¸‹ï¼Œä¾¿äºåˆå§‹æ›´ä½é€Ÿåº¦
                const apexMin = this.apexMinFactor || 0.7;
                const apexMax = this.apexMaxFactor || 0.82;
                const desiredApex = Math.max(260, this.height * (apexMin + Math.random() * (apexMax - apexMin)));
                const baseVy = -Math.sqrt(2 * CONFIG.GRAVITY * desiredApex);
                const vyJitter = 0.9 + Math.random() * 0.25; // 0.9x ~ 1.15x
                const vy = baseVy * vyJitter - this.difficultyMultiplier * 0.6;

                this.fruits.push({
                    x, y, vx, vy,
                    type: item.type,
                    icon: item.icon,
                    score: item.score,
                    color: item.color,
                    size: finalSize,
                    rotation: 0,
                    rotationSpeed: (Math.random() - 0.5) * 0.3,
                    isSliced: false,
                    active: true
                });

                // é™„å¸¦æ°´æœæ¦‚ç‡éšéš¾åº¦æå‡ï¼Œå¼€å±€æ›´ä½
                const burstProb = Math.min(0.30 * this.burstScale, (0.12 + this.difficultyMultiplier * 0.05) * this.burstScale);
                if (Math.random() < burstProb) {
                    setTimeout(() => {
                        // ç®€å•çš„é€’å½’è°ƒç”¨ï¼Œä½†è¦é˜²æ­¢æ— é™é€’å½’ï¼Œè¿™é‡Œæ‰‹åŠ¨æ·»åŠ ä¸€ä¸ª
                        // å®é™…é¡¹ç›®ä¸­æœ€å¥½æŠŠ spawnFruit æ‹†åˆ†ä¸º createFruit å’Œ scheduleSpawn
                        // è¿™é‡Œç®€å•å¤„ç†ï¼šç›´æ¥å†æ¨ä¸€ä¸ªæ°´æœè¿›æ•°ç»„ï¼Œä¸èµ° spawnFruit é€»è¾‘é¿å…æ­»å¾ªç¯
                        const item2 = FRUIT_TYPES[Math.floor(Math.random() * FRUIT_TYPES.length)];
                        this.fruits.push({
                            x: x + (Math.random() - 0.5) * 50,
                            y: y + 50,
                            vx: vx + (Math.random() - 0.5) * 2,
                            vy: vy * (0.9 + Math.random() * 0.2),
                            type: item2.type,
                            icon: item2.icon,
                            score: item2.score,
                            color: item2.color,
                            size: item2.size * (0.8 + Math.random() * 0.5),
                            rotation: 0,
                            rotationSpeed: (Math.random() - 0.5) * 0.3,
                            isSliced: false,
                            active: true
                        });
                    }, 100);
                }
            }

            updatePhysics() {
                // æ—¶é—´æµé€
                if (this.timeSlowTimer > 0) {
                    this.timeSlowTimer--;
                    this.timeSlowFactor = 0.5;
                } else {
                    this.timeSlowFactor = 1;
                }

                if (this.doubleScoreTimer > 0) {
                    this.doubleScoreTimer--;
                }

                // éš¾åº¦å¢åŠ 
                this.gameTime = Math.floor((Date.now() - this.startTime) / 1000);
                // éšæ—¶é—´æå‡éš¾åº¦ï¼šå…ˆæ›´æ–°å„é¡¹å‚æ•°ï¼Œå†ç´¯ç§¯éš¾åº¦ç³»æ•°
                this.applyDifficultyRamp(this.gameTime);
                this.difficultyMultiplier = this.difficultyBase + Math.min(1.5, (this.gameTime / 60) * 0.3);

                // æ›´æ–°æ—¶é—´æ˜¾ç¤ºï¼ˆä»…å½“ç§’æ•°å˜åŒ–æ—¶åˆ·æ–°ï¼‰
                this.refreshTimeDisplay();

                // ç”Ÿæˆæ°´æœ
                this.spawnTimer++;
                const currentSpawnRate = Math.max(this.spawnRateFloor, this.spawnRateInitial - (this.difficultyMultiplier * 6));
                if (this.spawnTimer > currentSpawnRate && this.fruits.length < this.maxFruits) {
                    this.spawnFruit();
                    this.spawnTimer = 0;
                }

                // æ›´æ–°æ°´æœä½ç½®
                for (let i = this.fruits.length - 1; i >= 0; i--) {
                    let f = this.fruits[i];
                    f.x += f.vx * this.timeSlowFactor;
                    f.y += f.vy * this.timeSlowFactor;
                    f.vy += CONFIG.GRAVITY * this.timeSlowFactor;
                    f.rotation += f.rotationSpeed * this.timeSlowFactor;

                    // ç§»é™¤å‡ºç•Œæ°´æœ
                    if (f.y > this.height + 100) {
                        if (!f.isSliced && f.type !== 'bomb' && f.type !== 'ice') {
                            // æ¼æ‰æ°´æœç›´æ¥æ‰£å‘½
                            this.lives--;
                            this.flashScreen('red'); // çº¢è‰²é—ªçƒè­¦ç¤º
                            this.playMissSound(); // æ’­æ”¾æ¼æ‰éŸ³æ•ˆ
                            this.createFloatingText(f.x, this.height - 100, "Missed!", "#ff0000"); // æç¤ºæ–‡å­—
                            this.createFloatingText(this.width / 2, this.height / 2, "-1 â¤ï¸", "#ff0000"); // å±å¹•ä¸­å¤®æç¤ºæ‰£è¡€
                            this.updateHUD();
                            if (this.lives <= 0) {
                                this.gameOver("æ¼æ‰å¤ªå¤šæ°´æœ!");
                            }
                        }
                        this.fruits.splice(i, 1);
                        continue;
                    }
                }

                // æ›´æ–°ç²’å­
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    let p = this.particles[i];
                    p.x += p.vx * this.timeSlowFactor;
                    p.y += p.vy * this.timeSlowFactor;
                    p.vy += CONFIG.GRAVITY * 0.5 * this.timeSlowFactor;
                    p.life--;
                    if (p.life <= 0) this.particles.splice(i, 1);
                }

                // æ›´æ–°èƒŒæ™¯æº…å°„
                for (let i = this.splatters.length - 1; i >= 0; i--) {
                    let s = this.splatters[i];
                    s.life--;
                    // æ¨¡æ‹Ÿé‡åŠ›æµæ·Œæ•ˆæœ (Dripping effect)
                    if (s.style === 'BLOB' || s.style === 'SPLASH') {
                        s.y += 0.2 * (s.size / 50); // å¤§çš„æµå¾—å¿«
                    }
                    if (s.life <= 0) this.splatters.splice(i, 1);
                }

                // æ›´æ–°æµ®åŠ¨æ–‡å­—
                for (let i = this.floatingTexts.length - 1; i >= 0; i--) {
                    let t = this.floatingTexts[i];
                    t.y += t.vy * this.timeSlowFactor;
                    t.life--;
                    t.scale += 0.01; // ç¨å¾®å˜å¤§
                    if (t.life <= 0) this.floatingTexts.splice(i, 1);
                }

                // æ›´æ–°åˆ€å…‰ (éå†æ‰€æœ‰è½¨è¿¹)
                for (let i = 0; i < this.bladeTrails.length; i++) {
                    if (this.bladeTrails[i].length > CONFIG.BLADE_LIFETIME) {
                        this.bladeTrails[i].shift();
                    }
                }
            }

            checkCollisions() {
                // ä¿®å¤å¤šæ‰‹è¯†åˆ«å¼‚å¸¸å¯¼è‡´çš„æ®‹ç•™è™šå½±
                // å¦‚æœæ£€æµ‹åˆ°çš„æ‰‹æ•°é‡å°‘äºä¹‹å‰çš„è½¨è¿¹æ•°é‡ï¼Œæ¸…é™¤å¤šä½™çš„è½¨è¿¹
                const detectedHandCount = this.handLandmarks ? this.handLandmarks.length : 0;
                for (let i = detectedHandCount; i < 2; i++) {
                    this.bladeTrails[i] = []; // ç«‹å³æ¸…é™¤æœªæ£€æµ‹åˆ°çš„æ‰‹çš„è½¨è¿¹
                }

                if (!this.handLandmarks) return;

                // éå†æ¯ä¸€åªæ‰‹
                for (let i = 0; i < this.handLandmarks.length; i++) {
                    const hand = this.handLandmarks[i];
                    const state = this.handStates[i];

                    // å¦‚æœæ˜¯å¼ æ‰‹(æš‚åœæ‰‹åŠ¿)ï¼Œä¸äº§ç”Ÿåˆ€å…‰
                    if (state === 'OPEN_PALM') {
                        this.bladeTrails[i] = []; // æ¸…ç©ºè¯¥æ‰‹çš„è½¨è¿¹
                        continue;
                    }

                    // è·å–é£ŸæŒ‡æŒ‡å°–åæ ‡
                    const indexTip = hand[8];

                    // 1. è½¬æ¢å½’ä¸€åŒ–åæ ‡åˆ°è§†é¢‘åŸå§‹åƒç´ åæ ‡
                    const dims = this.videoDims || { vw: this.video.videoWidth, vh: this.video.videoHeight };
                    const videoX = indexTip.x * dims.vw;
                    const videoY = indexTip.y * dims.vh;

                    // 2. æ˜ å°„åˆ° Canvas åæ ‡ï¼ˆåŸºäº letterbox ç¼©æ”¾ï¼Œä¸è£å‰ªè¾“å…¥ï¼‰
                    const mapping = this.videoMapping || { scale: 1, offsetX: 0, offsetY: 0 };
                    const canvasX = videoX * mapping.scale + mapping.offsetX;
                    const canvasY = videoY * mapping.scale + mapping.offsetY;

                    // 3. åº”ç”¨é•œåƒç¿»è½¬
                    const tipX = this.width - canvasX;
                    const tipY = canvasY;

                    // ç¡®ä¿è¯¥æ‰‹çš„è½¨è¿¹æ•°ç»„å­˜åœ¨
                    if (!this.bladeTrails[i]) this.bladeTrails[i] = [];

                    // æ·»åŠ åˆ°è½¨è¿¹
                    this.bladeTrails[i].push({ x: tipX, y: tipY, time: Date.now() }); // è®°å½•æ—¶é—´æˆ³

                    // ç¢°æ’æ£€æµ‹
                    if (this.bladeTrails[i].length < 2) continue;

                    const prev = this.bladeTrails[i][this.bladeTrails[i].length - 2];
                    const curr = { x: tipX, y: tipY };

                    // è®¡ç®—åˆ‡å‰²é€Ÿåº¦ï¼ˆåƒç´ /æ¯«ç§’ï¼‰
                    const timeDiff = Date.now() - (prev.time || Date.now());
                    const distDiff = Math.hypot(curr.x - prev.x, curr.y - prev.y);
                    const cutSpeed = timeDiff > 0 ? distDiff / timeDiff : 0;

                    for (let f of this.fruits) {
                        if (f.isSliced || !f.active) continue;

                        const dist = this.lineDist(prev, curr, { x: f.x, y: f.y });

                        // åˆ¤å®šèŒƒå›´ä¼˜åŒ–ï¼šä¿®æ­£åˆ¤å®šèŒƒå›´è¿‡å¤§çš„é—®é¢˜
                        // f.size æ˜¯å­—ä½“å¤§å°(è¿‘ä¼¼ç›´å¾„)ï¼Œè§†è§‰åŠå¾„çº¦ä¸º f.size/2
                        // PC: 0.6 (å³ 1.2å€åŠå¾„), Mobile: 0.8 (å³ 1.6å€åŠå¾„)
                        const hitboxScale = this.isMobile ? 0.8 : 0.6;
                        
                        if (dist < f.size * hitboxScale) {
                            // ä¼ å…¥å½“å‰æ‰‹çš„çŠ¶æ€ï¼Œç”¨äºåˆ¤æ–­æ˜¯å¦é˜²å¾¡ç‚¸å¼¹
                            this.sliceFruit(f, state, cutSpeed);
                        }
                    }
                }
            }

            lineDist(p1, p2, p) {
                const l2 = (p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2;
                if (l2 === 0) return Math.hypot(p.x - p1.x, p.y - p1.y);
                let t = ((p.x - p1.x) * (p2.x - p1.x) + (p.y - p1.y) * (p2.y - p1.y)) / l2;
                t = Math.max(0, Math.min(1, t));
                return Math.hypot(p.x - (p1.x + t * (p2.x - p1.x)), p.y - (p1.y + t * (p2.y - p1.y)));
            }

            sliceFruit(fruit, handState, cutSpeed = 0) {
                // é˜²æ­¢é‡å¤åˆ‡å‰² (Double Slice Guard)
                if (fruit.isSliced) return;
                
                fruit.isSliced = true;
                fruit.active = false; // æ ‡è®°ä¸ºéæ´»è·ƒï¼Œç¨åç§»é™¤æˆ–æ›¿æ¢ä¸ºç¢ç‰‡

                // ç‰¹æ®Šæ•ˆæœ
                if (fruit.type === 'bomb') {
                    if (handState === 'FIST') {
                        // é˜²å¾¡æˆåŠŸï¼Œä¸æ‰£åˆ†
                        this.createFloatingText(fruit.x, fruit.y, "Blocked!", "#fff");
                    } else {
                        this.lives--;
                        this.flashScreen('red'); // çº¢è‰²é—ªçƒè­¦ç¤º
                        this.playBombSound();
                        this.createFloatingText(fruit.x, fruit.y, "BOOM!", "#f00");
                        // å±å¹•éœ‡åŠ¨æ•ˆæœ
                        this.canvas.style.transform = `translate(${Math.random() * 10 - 5}px, ${Math.random() * 10 - 5}px)`;
                        setTimeout(() => this.canvas.style.transform = 'none', 200);
                    }
                } else if (fruit.type === 'ice') {
                    this.playSliceSound(fruit, cutSpeed);
                    this.timeSlowTimer = 300; // 5ç§’æ…¢åŠ¨ä½œ
                    this.createFloatingText(fruit.x, fruit.y, "Freeze!", "#0ff");
                } else {
                    this.playSliceSound(fruit, cutSpeed);
                    // æ™®é€šæ°´æœ
                    let points = fruit.score;
                    if (this.doubleScoreTimer > 0) {
                        points *= 2;
                    }
                    this.score += points;

                    // å¥–åŠ±æœºåˆ¶ï¼šæ¯è·å¾— 100 åˆ†å¥–åŠ± 1 æ¡ç”Ÿå‘½ (æœ€å¤š 3 æ¡)
                    if (Math.floor(this.score / 100) > Math.floor((this.score - points) / 100)) {
                        if (this.lives < 3) {
                            this.lives++;
                            this.createFloatingText(this.width / 2, this.height / 2, "Extra Life! +1 â¤ï¸", "#00ff00");
                        }
                    }

                    // è¿å‡»åˆ¤å®š
                    const now = Date.now();
                    if (now - this.lastSliceTime < CONFIG.COMBO_TIME_WINDOW) {
                        this.comboCount++;
                        if (this.comboCount > 1) {
                            this.score += this.comboCount; // è¿å‡»åŠ åˆ†
                            this.createFloatingText(fruit.x, fruit.y - 30, `${this.comboCount} COMBO!`, "#ff00ff");
                        }
                    } else {
                        this.comboCount = 1;
                    }
                    this.lastSliceTime = now;

                    this.createFloatingText(fruit.x, fruit.y, `+${points}`, "#ff0");

                    this.slicedFruitsTotal++;
                    if (this.slicedFruitsTotal % 10 === 0) {
                        const effectType = Math.random() > 0.5 ? 'SLOW' : 'DOUBLE';
                        if (effectType === 'SLOW') {
                            this.timeSlowTimer = 300; // 5 seconds
                            this.createFloatingText(this.width / 2, this.height / 3, "BONUS: TIME SLOW!", "#00ffff");
                        } else {
                            this.doubleScoreTimer = 300; // 5 seconds
                            this.createFloatingText(this.width / 2, this.height / 3, "BONUS: DOUBLE SCORE!", "#ffd700");
                        }
                    }
                }

                this.createParticles(fruit);
                this.updateHUD();

                if (this.lives <= 0) {
                    this.gameOver("åˆ‡åˆ°ç‚¸å¼¹!");
                }
            }

            flashScreen(color) {
                const flash = document.createElement('div');
                flash.style.position = 'absolute';
                flash.style.top = '0';
                flash.style.left = '0';
                flash.style.width = '100%';
                flash.style.height = '100%';
                flash.style.backgroundColor = color;
                flash.style.opacity = '0.5';
                flash.style.pointerEvents = 'none';
                flash.style.zIndex = '100';
                flash.style.transition = 'opacity 0.2s';
                document.body.appendChild(flash);
                
                requestAnimationFrame(() => {
                    flash.style.opacity = '0';
                });
                setTimeout(() => flash.remove(), 200);
            }

            createParticles(fruit) {
                // 1. èƒŒæ™¯æº…å°„ (Splatter) - å¢å¼ºç‰ˆï¼šå¤šç§æ ·å¼ã€å¤§å°å’Œå¯†åº¦
                if (fruit.type !== 'bomb' && fruit.type !== 'coconut') {
                    // éšæœºç”Ÿæˆ 1-3 ä¸ªæº…å°„å±‚ï¼Œå¢åŠ å¯†åº¦æ„Ÿ (ç§»åŠ¨ç«¯é™åˆ¶ä¸º1å±‚)
                    const splatterCount = this.isMobile ? 1 : (1 + Math.floor(Math.random() * 3));

                    for (let i = 0; i < splatterCount; i++) {
                        const rand = Math.random();
                        let style = 'BLOB'; // é»˜è®¤å¢¨ç‚¹
                        if (rand > 0.7) style = 'SPLASH'; // æ”¾å°„çŠ¶
                        else if (rand > 0.4) style = 'MIST'; // å–·é›¾çŠ¶

                        const splatter = {
                            x: fruit.x + (Math.random() - 0.5) * 60,
                            y: fruit.y + (Math.random() - 0.5) * 60,
                            color: fruit.color,
                            // è°ƒæ•´å¤§å°èŒƒå›´ï¼š0.7å€ - 1.3å€ (å‡å°å°ºå¯¸)
                            size: fruit.size * (0.7 + Math.random() * 0.6),
                            life: 120, // æŒç»­2ç§’
                            maxLife: 120,
                            rotation: Math.random() * Math.PI * 2,
                            style: style,
                            outline: [], // ç”¨äº BLOB æ ·å¼çš„å¤šè¾¹ä¸è§„åˆ™å¤–å½¢
                            blobs: [], // æ—§æ•°æ®ç»“æ„ä¿ç•™å…¼å®¹
                            points: [], // ç”¨äº SPLASH æ ·å¼çš„å¤šè¾¹å½¢
                            droplets: [] // ç”¨äº MIST æ ·å¼çš„æ¶²æ»´
                        };

                        // é¢„è®¡ç®—å½¢çŠ¶æ•°æ® (é¿å…æ¯å¸§æŠ–åŠ¨)
                        if (style === 'BLOB') {
                            // ç”Ÿæˆæ— è§„åˆ™å¤–å½¢ï¼šç¯ç»•ä¸€åœˆçš„ä¸ç­‰è·é¡¶ç‚¹
                            const pointCount = 24 + Math.floor(Math.random() * 14); // 24-37 ç‚¹
                            for (let j = 0; j < pointCount; j++) {
                                const angle = (j / pointCount) * Math.PI * 2 + (Math.random() - 0.5) * 0.12;
                                const radius = splatter.size * (0.55 + Math.random() * 0.55);
                                splatter.outline.push({
                                    x: Math.cos(angle) * radius,
                                    y: Math.sin(angle) * radius
                                });
                            }
                        } else if (style === 'SPLASH') {
                            // å°–é”çš„æ”¾å°„çŠ¶ - å¢åŠ ç‚¹æ•°
                            const numPoints = 20 + Math.floor(Math.random() * 15);
                            for (let j = 0; j < numPoints; j++) {
                                const angle = (j / numPoints) * Math.PI * 2;
                                // åŠå¾„å‰§çƒˆæ³¢åŠ¨
                                const r = splatter.size * (0.2 + Math.random() * 1.4);
                                splatter.points.push({
                                    x: Math.cos(angle) * r,
                                    y: Math.sin(angle) * r
                                });
                            }
                        } else if (style === 'MIST') {
                            // æ•£è½çš„å°æ¶²æ»´ - å¢åŠ æ•°é‡
                            const numDroplets = 12 + Math.floor(Math.random() * 10);
                            for (let j = 0; j < numDroplets; j++) {
                                const dist = Math.random() * splatter.size;
                                const angle = Math.random() * Math.PI * 2;
                                splatter.droplets.push({
                                    x: Math.cos(angle) * dist,
                                    y: Math.sin(angle) * dist,
                                    r: (Math.random() * 0.1 + 0.05) * splatter.size
                                });
                            }
                        }

                        this.splatters.push(splatter);
                    }
                }

                // 2. çˆ†ç‚¸ç²’å­ (Particles) â€” å…¨éƒ¨ä¸è§„åˆ™ï¼Œå¹¶é™åˆ¶å—çŠ¶å¤§å°
                const particleCount = this.particleCount;
                for (let i = 0; i < particleCount; i++) {
                    const verts = [];
                    const vertCount = 6 + Math.floor(Math.random() * 6); // 6-11 è¾¹
                    const baseR = 2 + Math.random() * 3; // æ§åˆ¶å—å¤§å°æ›´å°
                    for (let v = 0; v < vertCount; v++) {
                        // ä¸è§„åˆ™è§’åº¦ä¸åŠå¾„
                        const ang = Math.random() * Math.PI * 2;
                        const r = baseR * (0.5 + Math.random());
                        verts.push({ x: Math.cos(ang) * r, y: Math.sin(ang) * r });
                    }

                    this.particles.push({
                        x: fruit.x,
                        y: fruit.y,
                        vx: (Math.random() - 0.5) * 10,
                        vy: (Math.random() - 0.5) * 10,
                        life: 30 + Math.random() * 20,
                        color: fruit.color,
                        verts
                    });
                }

                // æ€§èƒ½ä¼˜åŒ–ï¼šé™åˆ¶æœ€å¤§ç²’å­æ•°ï¼Œé˜²æ­¢å¡é¡¿
                if (this.particles.length > 100) {
                    this.particles.splice(0, this.particles.length - 100);
                }

                // å¦‚æœä¸æ˜¯ç‚¸å¼¹ï¼Œç”Ÿæˆä¸¤åŠæ°´æœ (ä½¿ç”¨ Clip è£å‰ªæ¨¡æ‹Ÿåˆ‡å¼€æ•ˆæœ)
                if (fruit.type !== 'bomb') {
                    const sliceAngle = (Math.random() - 0.5) * Math.PI; // éšæœºåˆ‡åˆ†è§’åº¦
                    const sepSpeed = 4; // åˆ†ç¦»åŠ›åº¦

                    // å‚ç›´äºåˆ‡é¢çš„åˆ†ç¦»å‘é‡
                    const sepVx = Math.cos(sliceAngle + Math.PI / 2) * sepSpeed;
                    const sepVy = Math.sin(sliceAngle + Math.PI / 2) * sepSpeed;

                    // ç¬¬ä¸€åŠ
                    this.fruits.push({
                        ...fruit,
                        vx: fruit.vx + sepVx,
                        vy: fruit.vy + sepVy,
                        isSliced: true,
                        active: false,
                        rotationSpeed: fruit.rotationSpeed - 0.15,
                        sliceAngle: sliceAngle,
                        halfIndex: 1
                    });
                    // ç¬¬äºŒåŠ
                    this.fruits.push({
                        ...fruit,
                        vx: fruit.vx - sepVx,
                        vy: fruit.vy - sepVy,
                        isSliced: true,
                        active: false,
                        rotationSpeed: fruit.rotationSpeed + 0.15,
                        sliceAngle: sliceAngle,
                        halfIndex: 2
                    });
                }

                // ç§»é™¤åŸå§‹æ°´æœ
                const idx = this.fruits.indexOf(fruit);
                if (idx > -1) this.fruits.splice(idx, 1);
            }

            createFloatingText(x, y, text, color) {
                // æ€§èƒ½ä¼˜åŒ–ï¼šä½¿ç”¨ Canvas ç»˜åˆ¶æ–‡å­—ä»£æ›¿ DOM æ“ä½œ
                this.floatingTexts.push({
                    x: x,
                    y: y,
                    text: text,
                    color: color,
                    life: 60, // 60å¸§ (çº¦1ç§’)
                    vy: -2, // å‘ä¸Šé£˜
                    scale: 1
                });
            }

            updateHUD() {
                this.ui.score.innerText = this.score;
                if (this.ui.highScore) {
                    this.ui.highScore.innerText = this.highScore;
                }
                
                // æ›´æ–°æ—¶é—´æ˜¾ç¤º (MM:SS)
                this.refreshTimeDisplay(true);

                // æ›´æ–°ç”Ÿå‘½å€¼æ˜¾ç¤º (ä½¿ç”¨çˆ±å¿ƒå›¾æ ‡)
                const maxLives = 3;
                // å‰©ä½™ç”Ÿå‘½å€¼
                const currentLives = Math.max(0, this.lives);

                // æ¸…ç©ºå¹¶é‡æ–°ç”Ÿæˆ
                this.ui.livesContainer.innerHTML = '';
                for (let i = 0; i < maxLives; i++) {
                    const heartIcon = document.createElement('div');
                    heartIcon.className = 'life-icon';
                    heartIcon.innerText = 'â¤ï¸';

                    // å¦‚æœå½“å‰ç´¢å¼• >= å‰©ä½™ç”Ÿå‘½å€¼ï¼Œè¯´æ˜è¿™ä¸ªå¿ƒä¸¢äº†
                    // ä¾‹å¦‚ lives=2, i=0(ok), i=1(ok), i=2(lost)
                    if (i >= currentLives) {
                        heartIcon.classList.add('life-lost');
                        heartIcon.innerText = 'ğŸ¤'; // ä¸¢å¤±å˜æˆç™½å¿ƒæˆ–ç©ºå¿ƒ
                    }
                    this.ui.livesContainer.appendChild(heartIcon);
                }
            }

            // åªåœ¨ç§’æ•°å˜åŒ–æ—¶æ›´æ–°æ—¶é—´æ˜¾ç¤ºï¼Œå‡å°‘è·³å˜ä¸å¡é¡¿
            refreshTimeDisplay(force = false) {
                if (!this.ui.time) return;
                if (!force && this.gameTime === this.lastDisplayedTime) return;
                this.lastDisplayedTime = this.gameTime;
                const minutes = Math.floor(this.gameTime / 60).toString().padStart(2, '0');
                const seconds = (this.gameTime % 60).toString().padStart(2, '0');
                this.ui.time.innerText = `${minutes}:${seconds}`;
            }

            draw() {
                // æ¸…ç©ºç”»å¸ƒ
                this.ctx.clearRect(0, 0, this.width, this.height);

                // 1. ç»˜åˆ¶æ‘„åƒå¤´èƒŒæ™¯ (é•œåƒ)
                this.ctx.save();
                this.ctx.scale(-1, 1);
                this.ctx.translate(-this.width, 0);
                if (this.video.readyState === 4 && this.videoMapping) {
                    const map = this.videoMapping;
                    const dims = this.videoDims || { vw: this.video.videoWidth, vh: this.video.videoHeight };
                    const destX = this.width - map.offsetX - map.drawW; // é•œåƒåä»å³å¾€å·¦æ”¾ç½®
                    this.ctx.drawImage(
                        this.video,
                        0, 0, dims.vw, dims.vh,
                        destX, map.offsetY, map.drawW, map.drawH
                    );
                } else {
                    // å¤‡ç”¨èƒŒæ™¯
                    const gradient = this.ctx.createLinearGradient(0, 0, this.width, this.height);
                    gradient.addColorStop(0, '#2c3e50');
                    gradient.addColorStop(1, '#3498db');
                    this.ctx.fillStyle = gradient;
                    this.ctx.fillRect(0, 0, this.width, this.height);
                }
                this.ctx.restore();

                // 1.5 ç»˜åˆ¶èƒŒæ™¯æœæ±æº…å°„ (Splatters)
                for (let s of this.splatters) {
                    this.ctx.save();
                    this.ctx.translate(s.x, s.y);
                    this.ctx.rotate(s.rotation);
                    // å¢åŠ é€æ˜åº¦ï¼Œè®©å®ƒçœ‹èµ·æ¥åƒæ¶²ä½“é™„ç€åœ¨è¡¨é¢
                    this.ctx.globalAlpha = Math.min(0.85, s.life / 60);
                    this.ctx.fillStyle = s.color;

                    if (s.style === 'MIST') {
                        // ç»˜åˆ¶æ•£è½æ¶²æ»´
                        for (let d of s.droplets) {
                            this.ctx.beginPath();
                            this.ctx.arc(d.x, d.y, d.r, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                    } else if (s.style === 'BLOB') {
                        // ä½¿ç”¨é¢„è®¡ç®—çš„ä¸è§„åˆ™å¤–å½¢ï¼Œé¿å…å‡ºç°è§„åˆ™åœ†å½¢
                        if (s.outline && s.outline.length > 2) {
                            this.ctx.beginPath();
                            this.ctx.moveTo(s.outline[0].x, s.outline[0].y);
                            for (let i = 1; i < s.outline.length; i++) {
                                this.ctx.lineTo(s.outline[i].x, s.outline[i].y);
                            }
                            this.ctx.closePath();
                            this.ctx.fill();

                            if (!this.isMobile) {
                                this.ctx.save();
                                this.ctx.globalAlpha *= 0.25;
                                this.ctx.fillStyle = '#ffffff';
                                // åœ¨å¤–å½¢å†…éšæœºæ”¾ç½®ä¸€ä¸ªå°é«˜å…‰ï¼Œä¿æŒä¸è§„åˆ™æ„Ÿ
                                const pick = s.outline[Math.floor(Math.random() * s.outline.length)];
                                const hiSize = s.size * 0.15;
                                this.ctx.beginPath();
                                this.ctx.ellipse(pick.x * 0.3, pick.y * 0.3, hiSize, hiSize * 0.6, Math.PI / 3, 0, Math.PI * 2);
                                this.ctx.fill();
                                this.ctx.restore();
                            }
                        }
                    } else {
                        // SPLASH ä½¿ç”¨é¢„è®¡ç®—çš„å¤šè¾¹å½¢
                        if (s.points && s.points.length > 0) {
                            this.ctx.beginPath();

                            // SPLASH ä¿æŒå°–é”
                            this.ctx.moveTo(s.points[0].x, s.points[0].y);
                            for (let i = 1; i < s.points.length; i++) {
                                this.ctx.lineTo(s.points[i].x, s.points[i].y);
                            }

                            this.ctx.closePath();
                            this.ctx.fill();

                            // æ·»åŠ æ¶²ä½“é«˜å…‰ (Wet Highlight) - ç®€å•é«˜æ•ˆçš„æ¨¡æ‹Ÿ
                            if (!this.isMobile) {
                                this.ctx.globalAlpha *= 0.4; // é«˜å…‰é€æ˜åº¦
                                this.ctx.fillStyle = '#ffffff';
                                // åœ¨å·¦ä¸Šè§’ç»˜åˆ¶ä¸€ä¸ªæ¨¡ç³Šçš„åå°„å…‰æ–‘
                                this.ctx.beginPath();
                                // æ ¹æ®å½¢çŠ¶å¤§å°è°ƒæ•´é«˜å…‰
                                const highlightSize = s.size * 0.25;
                                const highlightOffset = s.size * 0.2;
                                // ç»˜åˆ¶ä¸€ä¸ªæœˆç‰™å½¢æˆ–æ¤­åœ†
                                this.ctx.ellipse(-highlightOffset, -highlightOffset, highlightSize, highlightSize * 0.6, Math.PI / 4, 0, Math.PI * 2);
                                this.ctx.fill();
                            }
                        }
                    }
                    this.ctx.restore();
                }
                this.ctx.globalAlpha = 1;

                // 2. ç»˜åˆ¶æ°´æœ
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                for (let f of this.fruits) {
                    this.ctx.save();
                    this.ctx.translate(f.x, f.y);
                    this.ctx.rotate(f.rotation);
                    this.ctx.font = `${f.size}px "Segoe UI Emoji", "Segoe UI Symbol", Arial`;

                    if (f.isSliced && f.halfIndex) {
                        // ç»˜åˆ¶åˆ‡å¼€çš„åŠä¸ªæ°´æœ
                        this.ctx.save();

                        // æ—‹è½¬åˆ°åˆ‡åˆ†è§’åº¦è¿›è¡Œè£å‰ª
                        this.ctx.rotate(f.sliceAngle);
                        this.ctx.beginPath();
                        if (f.halfIndex === 1) {
                            // ä¸ŠåŠéƒ¨åˆ† (ç›¸å¯¹äºåˆ‡åˆ†çº¿)
                            this.ctx.rect(-f.size, -f.size, f.size * 2, f.size);
                        } else {
                            // ä¸‹åŠéƒ¨åˆ†
                            this.ctx.rect(-f.size, 0, f.size * 2, f.size);
                        }
                        this.ctx.clip();

                        // æ—‹è½¬å›æ¥ç»˜åˆ¶ Emojiï¼Œä¿æŒçº¹ç†æ–¹å‘ä¸€è‡´
                        this.ctx.rotate(-f.sliceAngle);
                        this.ctx.fillText(f.icon, 0, 0);

                        this.ctx.restore();
                    } else {
                        this.ctx.fillText(f.icon, 0, 0);
                    }
                    this.ctx.restore();
                }

                // 3. ç»˜åˆ¶ç²’å­
                for (let p of this.particles) {
                    this.ctx.fillStyle = p.color;
                    this.ctx.globalAlpha = Math.max(0, p.life / 50);
                    this.ctx.beginPath();
                    if (p.verts && p.verts.length) {
                        this.ctx.moveTo(p.x + p.verts[0].x, p.y + p.verts[0].y);
                        for (let k = 1; k < p.verts.length; k++) {
                            this.ctx.lineTo(p.x + p.verts[k].x, p.y + p.verts[k].y);
                        }
                        this.ctx.closePath();
                    } else {
                        this.ctx.arc(p.x, p.y, 2.5, 0, Math.PI * 2);
                    }
                    this.ctx.fill();
                }
                this.ctx.globalAlpha = 1;

                // 3.1 ç»˜åˆ¶æµ®åŠ¨æ–‡å­—
                this.ctx.save();
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.shadowColor = 'black';
                this.ctx.shadowBlur = 2;
                this.ctx.shadowOffsetX = 2;
                this.ctx.shadowOffsetY = 2;

                for (let t of this.floatingTexts) {
                    this.ctx.fillStyle = t.color;
                    this.ctx.font = `bold ${30 * t.scale}px Arial`;
                    this.ctx.globalAlpha = Math.min(1, t.life / 20); // æœ€å20å¸§æ¸éš
                    this.ctx.fillText(t.text, t.x, t.y);
                }
                this.ctx.restore();

                // 4. ç»˜åˆ¶åˆ€å…‰è½¨è¿¹ (æ”¯æŒå¤šæ‰‹)
                this.ctx.lineWidth = 5;
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';

                const colors = ['#00ffff', '#ff00ff']; // ä¸åŒæ‰‹ä¸åŒé¢œè‰²

                for (let i = 0; i < this.bladeTrails.length; i++) {
                    const trail = this.bladeTrails[i];
                    if (!trail || trail.length < 2) continue;

                    this.ctx.beginPath();
                    this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';

                    this.ctx.moveTo(trail[0].x, trail[0].y);
                    for (let j = 1; j < trail.length; j++) {
                        this.ctx.lineTo(trail[j].x, trail[j].y);
                    }
                    this.ctx.stroke();

                    // åˆ€å…‰å‘å…‰æ•ˆæœ
                    this.ctx.shadowBlur = 10;
                    this.ctx.shadowColor = colors[i % colors.length];
                    this.ctx.stroke();
                    this.ctx.shadowBlur = 0;
                }

                // 5. ç»˜åˆ¶æ‰‹åŠ¿è¯†åˆ«ç‚¹ (è°ƒè¯•ç”¨)
                if (this.handLandmarks && this.video.readyState >= 2) {
                    const dims = this.videoDims || { vw: this.video.videoWidth, vh: this.video.videoHeight };
                    const map = this.videoMapping || { scale: 1, offsetX: 0, offsetY: 0 };

                    this.ctx.fillStyle = '#00ff00';
                    for (const landmarks of this.handLandmarks) {
                        // Helper to map coordinates using letterbox mapping
                        const mapCoord = (p) => {
                            const vx = p.x * dims.vw;
                            const vy = p.y * dims.vh;
                            const cx = vx * map.scale + map.offsetX;
                            const cy = vy * map.scale + map.offsetY;
                            return { x: this.width - cx, y: cy };
                        };

                        // ç»˜åˆ¶é£ŸæŒ‡æŒ‡å°–
                        const tip = landmarks[8];
                        const tipPos = mapCoord(tip);

                        this.ctx.beginPath();
                        this.ctx.arc(tipPos.x, tipPos.y, 10, 0, Math.PI * 2);
                        this.ctx.fill();

                        // ç»˜åˆ¶æ‰‹è…•ä½œä¸ºå‚è€ƒ
                        const wrist = landmarks[0];
                        const wristPos = mapCoord(wrist);

                        this.ctx.fillStyle = '#ffff00';
                        this.ctx.beginPath();
                        this.ctx.arc(wristPos.x, wristPos.y, 5, 0, Math.PI * 2);
                        this.ctx.fill();
                        this.ctx.fillStyle = '#00ff00';
                    }
                }

                // 6. ç»˜åˆ¶èœå•äº¤äº’è¿›åº¦ (æ‚¬åœå…‰åœˆ)
                if (this.menuHoverTarget && this.menuHoverTimer > 0) {
                    const progress = this.menuHoverTimer / this.menuHoverMaxTime;
                    this.ctx.beginPath();
                    this.ctx.arc(this.menuHoverTarget.x, this.menuHoverTarget.y, 30, -Math.PI / 2, -Math.PI / 2 + progress * Math.PI * 2);
                    this.ctx.strokeStyle = '#00ff00';
                    this.ctx.lineWidth = 5;
                    this.ctx.stroke();

                    this.ctx.beginPath();
                    this.ctx.arc(this.menuHoverTarget.x, this.menuHoverTarget.y, 30, 0, Math.PI * 2);
                    this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    this.ctx.lineWidth = 5;
                    this.ctx.stroke();
                }

                // 7. ç»˜åˆ¶æ‰‹åŠ¿é•¿æŒ‰è¿›åº¦ (é‡ç½®/æš‚åœ)
                if (this.gestureState === 'TWO_HANDS_OPEN' && this.gestureStartTime) {
                    const elapsed = Date.now() - this.gestureStartTime;
                    const progress = Math.min(1, elapsed / 1500);

                    this.ctx.save();
                    this.ctx.translate(this.width / 2, this.height / 2);

                    // èƒŒæ™¯åœˆ
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, 60, 0, Math.PI * 2);
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    this.ctx.fill();

                    // è¿›åº¦åœˆ
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, 60, -Math.PI / 2, -Math.PI / 2 + progress * Math.PI * 2);
                    this.ctx.strokeStyle = '#ff4444'; // çº¢è‰²è­¦å‘Šè‰²
                    this.ctx.lineWidth = 10;
                    this.ctx.stroke();

                    this.ctx.fillStyle = '#fff';
                    this.ctx.font = '20px Arial';
                    this.ctx.fillText("é‡ç½®ä¸­...", 0, 5);

                    this.ctx.restore();
                } else if (this.gestureState === 'OPEN_PALM' && this.gestureStartTime) {
                    const elapsed = Date.now() - this.gestureStartTime;
                    const progress = Math.min(1, elapsed / 2000);

                    this.ctx.save();
                    this.ctx.translate(this.width / 2, this.height / 2);

                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, 50, -Math.PI / 2, -Math.PI / 2 + progress * Math.PI * 2);
                    this.ctx.strokeStyle = '#ffff00'; // é»„è‰²
                    this.ctx.lineWidth = 8;
                    this.ctx.stroke();

                    this.ctx.fillStyle = '#fff';
                    this.ctx.font = '16px Arial';
                    this.ctx.fillText("æš‚åœ...", 0, 5);

                    this.ctx.restore();
                }
            }

            checkMenuInteraction() {
                if (!this.handLandmarks || this.handLandmarks.length === 0) {
                    this.menuHoverTimer = 0;
                    this.menuHoverTarget = null;
                    return;
                }

                // ç¡®å®šå½“å‰åº”è¯¥æ£€æµ‹å“ªä¸ªæŒ‰é’®
                let targetBtn = null;
                if (this.state === 'MENU') targetBtn = this.ui.startBtn;
                else if (this.state === 'GAMEOVER') targetBtn = this.ui.restartBtn;
                else if (this.state === 'PAUSED') targetBtn = this.ui.resumeBtn;

                if (!targetBtn) return;

                const rect = targetBtn.getBoundingClientRect();
                let isHovering = false;

                // æ£€æŸ¥ä»»æ„ä¸€åªæ‰‹çš„é£ŸæŒ‡æ˜¯å¦åœ¨æŒ‰é’®åŒºåŸŸå†…
                for (const hand of this.handLandmarks) {
                    const indexTip = hand[8];

                    // æ˜ å°„åæ ‡ (å¤ç”¨ letterbox æ˜ å°„)
                    const dims = this.videoDims || { vw: this.video.videoWidth, vh: this.video.videoHeight };
                    const videoX = indexTip.x * dims.vw;
                    const videoY = indexTip.y * dims.vh;
                    const map = this.videoMapping || { scale: 1, offsetX: 0, offsetY: 0 };
                    const canvasX = videoX * map.scale + map.offsetX;
                    const canvasY = videoY * map.scale + map.offsetY;
                    const tipX = this.width - canvasX;
                    const tipY = canvasY;

                    // ç®€å•çš„çŸ©å½¢ç¢°æ’æ£€æµ‹
                    if (tipX >= rect.left && tipX <= rect.right &&
                        tipY >= rect.top && tipY <= rect.bottom) {
                        isHovering = true;
                        this.menuHoverTarget = { x: tipX, y: tipY }; // è®°å½•æ‚¬åœä½ç½®ç”¨äºç»˜åˆ¶è¿›åº¦
                        break;
                    }
                }

                if (isHovering) {
                    this.menuHoverTimer++;
                    // è§†è§‰åé¦ˆï¼šæŒ‰é’®è½»å¾®ç¼©æ”¾
                    targetBtn.style.transform = `scale(${1 + this.menuHoverTimer / this.menuHoverMaxTime * 0.1})`;

                    if (this.menuHoverTimer >= this.menuHoverMaxTime) {
                        targetBtn.click();
                        this.menuHoverTimer = 0;
                        this.menuHoverTarget = null;
                        targetBtn.style.transform = '';
                    }
                } else {
                    this.menuHoverTimer = Math.max(0, this.menuHoverTimer - 5); // å¿«é€Ÿè¡°å‡
                    if (this.menuHoverTimer === 0) {
                        this.menuHoverTarget = null;
                        targetBtn.style.transform = '';
                    }
                }
            }

            loop() {
                if (this.state === 'PLAYING') {
                    this.updatePhysics();
                    this.checkCollisions();
                } else if (['MENU', 'GAMEOVER', 'PAUSED'].includes(this.state)) {
                    this.checkMenuInteraction();
                }

                this.draw();
                requestAnimationFrame(() => this.loop());
            }
        }

        // å¯åŠ¨æ¸¸æˆ
        const game = new FruitNinjaGame();

    </script>
</body>

</html>